{"pages":[{"title":"Snippets","text":"#Point of No Return Andre Vltchek &quot;I have no religion to convert from,&quot; I wrote.&quot;No religion? Don&apos;t you feel scared?&quot;&quot;Scared of what?&quot;&quot;Scared of not belonging to anything.&quot;&quot;No. But I feel scared of belonging to something that teaches people to believe in the unknown.&quot; $10/29/22$ As I crossed te bridge, I looked back at the city. It had never seemed to hold me back, to stop me, to change my mind. It never seemed to judge me. It merely stood there, arrogant, proud, indifferent, cold, and yet full of promise, and beauty. $3/1/23$ #Nineteen Eighty-Four George Orwell Until they become conscious they will never rebel, and until after they have rebelled they cannot become conscious. $2/17/23$ The pencil felt thick and awkward in his fingers. He began to write down the thoughts that came into his head. He wrote first in large clumsy capitals: FREEDOM IS SLAVERY. Then almost without a pause he wrote beneath it: TWO AND TWO MAKE FIVE. $2/28/23$ #Being Mortal Atul Gawande For human beings, life is meaning ful because it is a story. A story has a sense of a whole, and its arc is determined by the significant moments, the ones where something happens. $3/4/23$ #A Journey, through Time, with Anthony Anthony Why do we travel?Maybe, it&apos;s because that someone, something, or somewhere, once you leave behind you can never return. Or think that you won&apos;t be able to return. $8/20/23$ #Zen and the Art of Motorcycle Maintenance - an Inquiry into Values Robert M. Pirsig The past exists only in our memories, the future only in our plans. The present is our only reality. $12/15/23$ Trials never end, of course. Unhappiness and misfortune are bound to occur as long as people live, but there is a feeling now, that was not here before, and is not just on the surface of things, but penetrates all the way through: We&apos;ve won it. It&apos;s going to get better now. You can sort of tell these things. $12/30/23$","link":"/snippets/index.html"}],"posts":[{"title":"Flashing Pixel Experience into OP 8T","text":"I flashed Pixel Experience into my OP 8T recently. Here&apos;re some problems I ran into. #Flashing Pixel ExperienceThe information in the Pixel Experience Official Instructions has covered about everything needed when flashing. Here&apos;re some problems I ran into. Actually, various solutions can be found online. I&apos;ll take down some useful methods here, so I do not have to search for it again. No device found when running fastboot devices It is a driver issue. Install the Android Bootloader Interface driver will do the trick. The copy-partitions-20210323_1922.zip file mentioned in the pre-install instructions section couldn&apos;t be downloaded. This file does not exist in the original repo. This is a subsitude. Everything works just fine with it. The PE recovery could not flash the firmware. Error code error in /sideload/package.zip (status 1) I have no idea what triggered it. By switching to twrp recovery, the flashing progress went on just fine. Although the instructions says the other ways. Don&apos;t relock bootloader It was mentioned in the Post-install instructionsthat relock will be okay after flashing avb_custom_key. Remember, you need to be sure you have succeeded flashing the avb_custom_key. I didn&apos;t. Hence the horrifying &quot;your device is corrupt. It can&apos;t be trusted and will not boot&quot; shows up. If you did the same thing as I did. Don&apos;t panic, I found a way to re-unlock the bootloader. Steps: power+volume up, Power off completely. volume down+volume up, then connect the label, voila~, you&apos;re in the fastboot mode. If the method above did not work. The best and valid-for-sure method is 9008 flashing. #Problems When Using Call recording It&apos;s said Android is gonna support it. However PE Plus version has not supported it yet. Magisk module Call Recorder - SKVALEX will do the trick. There&apos;re other modules as well. I haven&apos;t tried each one of them yet. SMS blocking This is a problem I have not found a way to solve. Hide Google Play updating informing. A major problem I have with Google Play is that you can&apos;t hide the updating informing of applications. The Detach module will solve the problem. The instructions is clear in the official repository. Hide application list. If you have had fun with rooting phones, you are definitely familiar with this function. It&apos;s a method to protect our privacy, in a way. Here is the original github repository. You need LSPosed module to use it properly. Network Access Control The official control method requires us setting the access app by app, which is overly inconvenient. AFWall+ does help with it. Simply checking or unchecking the app under LAN, WiFi, Mobile Data will do the trick.","link":"/2022/8T-flashing"},{"title":"The year 2023","text":"Better than 2022, that&apos;s for sure. #The end of the pandemic To not forget. A late ending and a topic that might not be appropriate to talk about in public. We all knew things are gonna be fine in the end, yet the way it ended still surprised me. I&apos;m in no place to judge whether the past three years of fighting against the pandemic was a success. Judgments are for historians to make. Being someone regular people who lived through the dark days, all I can do is to memorize the absurd things happened along, and to mourn for the ones who did not make it out. There&apos;re particular things that means nothing but to let you know that people are NOT supposed to forget sufferings. #A new start to the careerTo be honest, I thought I&apos;m gonna work full-time on finite element analysis. However, the post means a lot more than that, which I still can&apos;t say for sure whether it is a good thing. I don&apos;t intend to say much about the work, whether it is a dream job, or wether I would recommend people doing it. People of various occupation are faced with various troubles. Working as an automobile safety engineer, I mean simply working and studying, is fun, and important to a car as well. However, working in this particular region means that you gotta do a lot other than that. Each division has got their own target for all kinds, for example, paper work, innovation, etc. People tend to lose focus on the things that really matter. Being a safety engineer means a lot of responsibility. As long as cars have to actually travel instead of teleporting, crashes are very likely to happen no matter how advanced the autopilot is. And this makes restraint systems important during car crashes. Seats, seatbelts, airbags all contribute to the overall performance of restraint system. There&apos;re assessment protocols, as well as obliged standards, of different kind from different regions. In Europe, Euro NCAP assessment results would represent whether a car make is safe. In China, C-NCAP and C-IASI are playing the very same role. In the States, there&apos;s IIHS, NHTSA, etc. A fun part of studying the developing these systems is that you get to understand different considerations on safety from people of different regions, which, to some extent, reflects the diversity of culture. #LifeIt is not all about working. Again, due to some un-speakable reasons, people from this region have no choice, in a sense. I met someone from Germany the other day, who expressed very explicitly that the amount of work we are doing nowadays compares to exactly what they do in at least two years. Both of us find it funny, and yet there&apos;s just no chance that things could be different. During the school years, teachers always say that real friends are rear after joining work. They are RIGHT. There&apos;s just too much to consider, to balance when you actually think about developing a relationship. I mean it, for both friendship and intimacy. I&apos;ve come to realize that I&apos;m gradually adapting to the solo life. Books, movies, musics took most of the spare time. Got no problem with communicating with people, yet being alone just gives me peace and fun, which is a great relief after the noisy and busy work. #A new languageFound it fun to learn languages during a project I participated during collage. We did some simple research on the distinction of languages and the cultural factors that contributes to it. Part of the conclusion is that if you mastered English, Spanish and German, it&apos;s very likely that you get to travel through most of west Europe and America with no problem. And for east Europe, Russian would be the number one choice. Africa on the other hand, is very complex. Worked on a subject that has a lot to do with Europe this year. It came into mind that I gotta know another language which works there. With the researches ahead, One&apos;s aware that the basic theory of pronunciation of Spanish is similar to the PINYIN of Mandarin. Why not give it a shot? Let&apos;s see how things work out next year. ^_^ #An old habitThis work, I have to say, is pretty exhausting. With it draining all the energy, one does not get to think much about what he truly likes. Again, life is not all about working and surviving. It is, as the word life implies, about living, and enjoying. During the years when we were in college do those researching, we would go to bars to relax. Either cocktail bars or cafes will do. As gradually losing contracts with those old friends from college, this habit gradually cleared away as well. Then one day, when finally a bottle of black rum turned up and caught my sight when I was wandering in a supermarket, all the joys we shared hit my back. Chatting with bartender or coffee maker is always a good entertainment. People like me tend to talk to unfamiliar ones so that there&apos;s nothing to worry even if something wrong was spitted out. After stepping out of the door, all the talking is just in the past. Nothing is left there to memorize. That&apos;s exactly the key to set loose of all the burden, and maintaining in a good mood. It&apos;s a new year, keep smiling.","link":"/2024/annualSummary23"},{"title":"The year 2022","text":"There&apos;s not so much to summary, to be honest. But I felt like something needed to be done so as to make every day, every month matters in the years to come. The first few months were all messed up, to be fair. Failed at a major examination, wasted about a month preparing things that would never come true. However, looking back, the time was not totally wasted. It helped me realizing something about myself, something about what I&apos;m capable of as well as what I&apos;m not. It also helped to get back into some habits that I have lost during the college years. To be honest, it&apos;s not the kind of college life I was expecting. Even though passed all the test, graduated with no hard time, I was expecting it to be a lot more colorful. But who am I to blame except myself. #Ways to know a cityThis, I&apos;m not gonna lie, is my major gaining this year. Gotta say that I had a whole different plan for the year. But I&apos;m more than happy that things did not go as that. Turns out, I like it here, more than anywhere I&apos;ve been. The six months I spent here really changed how I treat my life, probably in the best way I can see. One&apos;s gotta go out and see things rather that just sitting in front of a desk with some books and a laptop. Life is about not just getting to know things, but also experiencing, appreciating and enjoying. With all the technologies upgrading, one can get a whole lot of information about a specific thing by just a click. But one can only get to fully know about it standing right there, breathing the same air over there. To get to know about a city, I gotta say, there&apos;re four things at least one&apos;s gonna do. One, paying some visit to the local museums, especially local cultural ones. Those museums are the fastest and most easy way to learn about the city. Two, visiting the parks. Parks are places where more detailed histories are stored. Every park, I mean, not the ones only for exercising, has a specific topic, the industrialization of the city, the natural environment, etc. Each park will provide some brand-new vision. However, I gotta say information parks can provide is not so much as museums. They are for relaxation, mostly. Three, spending some decent time in sports venues, libraries or book stores. It&apos;s the easiest way to talk to strangers. You&apos;ll need only one topic to start a real long talk, weather. Well, I guess it works in most circumstances. But in these places, one&apos;s more likely to get to know people of the same interests. It&apos;s very possible that a long-lasting relationship is formed during the communication, friendship, love, whatever it might be. And, last but not least, taking some random tours inside the city. There&apos;re always places that one has never been to. My listing it last doesn&apos;t mean that it should be done last. It&apos;s the kind of thing that one can do every weekend. You got a car, drive wherever you want, a bike, ride. None? Pick a bus station with multiple transportation lines. Get on the next or whichever to arrive. Then get off at whichever station that attracts you, maybe for no reason. Make it random. Randomnesses enrich life, to a great extent. #Some ComplaintsBeen waiting for a better year for three years. Finally a more REGULAR year is coming into sight. I&apos;m not gonna say a thing about whether it is right to put all the pressure on people against the pandemic. But being under so much pressure for the past three years has really made me clear about some particular things, which I might have to keep to myself for ever. But we&apos;re now looking at a much brighter sunrise, aren&apos;t we? Even though we&apos;ve paid the price, which was not so cheap. A little off topic. LOL. #What to expect for 2023During the working days, I came up with some idea about how to simplify my working routine so as to improve the efficiency. I might land on some of those after the Chinese NEW YEAR. Some posts might be on the way, HAHA. Mostly skills, I think. One is never too old too learn, let alone being a fresh graduate. I now work mainly about CAE analysis. There&apos;s a lot to learn about, ways to improve the simulating accuracy, ways to simplify modeling process, etc. A better location to live. There&apos;s simply nothing to do in my neighborhood. One&apos;s gonna need communication with other people to enrich life. Bars, playgrounds, libraries would be nice to be around. At least public transportation should be convenient to access. Slowing down. People are thinking less nowadays. There&apos;s just so much pressure everyday that people tend to go home and rest for the whole evening. With the development of internet technology, one get access to information in a much faster way. Side effects come with it. Taking in so much information in a short time leaves us no time to think. It&apos;s time to put down the smart phones, and find a way to slow down the pace and enjoy life. Reading, meditating, learning some soft instruments would be a way out. PS: It&apos;s Chinese new year&apos;s night tonight! Happy new year!","link":"/2023/annualSummary22"},{"title":"Review on the Firsts in Life","text":"#ForewordThe Firsts in Life focuses on lives of ordinary people, introduces you to people of different life periods, reveals the impermanence of life. The heroes and heroines of the documentary come from cities and countryside, from less than five y.o., all the way to eighties. People of different ages are faced with various problems, but all appeared to be fully delighted with how life is going on. I gotta say, making compromises with life from time to time is the secret of staying happy. Funny story, though, this particular documentary caught my sight about a year ago, yet I didn&apos;t start until this girl I used to have a crush on talked about it the other day. I&apos;ve always been keen at documentaries about nature and history, but this one did give me another view at humanity social documentaries. #Impressive snippets#E12 It&apos;s okay if you forget about me Perhaps, death is not the opposite of life, oblivion is. This is the sentence leads the whole episode. The last episode is kinda special, it focuses on only one family, of which one suffered with AD, also known as Alzheimer&apos;s disease. I&apos;m not gonna go detailed about the content of the episode. Documentaries are much better to watch and enjoy. No words, no presents can even level with the romance shown between the couple. It doesn&apos;t require any kind of epic scenes, or heroic acts to show love to your beloved. It is to accompany her all the way through days, good ones as well as bad ones. In the end of the episode, there&apos;s this line in the narration, &quot;he&apos;s worried that his wife would forget him&quot;. The husband was just diagnosed with tumor, which was luckily confirmed benign later. News like this did not bring him any fear, yet her oblivion has been for years. I have no idea what love really means. Maybe there could not ever be an explicit definition. However, what love is capable of was portrayed vividly by this couple. &quot;Death gives me far less fear than your oblivion.&quot; What kind of luck it is that one gets to say this out loud in eighties. #E9 Stay together What is the sweetest thing to say? Your tumor is benign. As an old man said in the episode, &quot;cancer is in the hands of fate, and you can&apos;t avoid it&quot;. One of the places that I hate to go to is a hospital. There&apos;s so much misfortune to see, that I can&apos;t bear with it, that I realized being happy everyday is as simple as staying safe and sound, having a meal together with family. Gotta stay optimistic about everything. Mood influences no only ourselves but probably everybody around, families, friends. To most people, disease like cancer is like a life sentence. They tend to lose their hope. In this episode, there&apos;s this couple, husband of which is always like, &quot;HAHA&quot; even if he was diagnosed with cancer. Dealing with life is never about oneself. It&apos;s about one&apos;s family, one&apos;s friends, even strangers are related. The wife said to the camera, &quot;it&apos;s like the world has collapsed&quot;. And yet they managed to go through the operations, the chemotherapies. As the narration goes, &quot;out of optimism, he accepts the fact of cancer. It is the constant companion of his wife that keeps him going&quot;. I&apos;d say vice versa, it&apos;s her husband optimism that keeps her going. Family is all about mutual support. &quot;You&apos;re not alone&quot; is just the kind of things one needs when they&apos;re facing difficulties, especially from one&apos;s family. #E10 We&apos;re going to schoolThis episode talks about retirement, mainly about the ones entering senior universities. It touched me because my parents are also about to retire from work. I&apos;ve been trying to find some thing that may interest them, keep them occupied after that. I&apos;ve seen so many people getting older faster than ever after retirement. One lose his/her routine all out of a sudden, and has no clue what to do every day. It&apos;s just HARD for some people. In this senior universities, there&apos;s so many things you get to do, dance, musical instrument, poetry, etc. It&apos;s never too late to find what interests oneself. Life is not supposed to be boring after retirement. It&apos;s supposed to be colorful than ever before. People of their age, had dreams, hobbies at their twenties. But not many people maintained these as they fighting for a better life, for themselves, for their offspring. It&apos;s the perfect timing for them to make up for the regrets. As sons and daughters, we gotta find a way to talk them into it, to talk them out of the shyness of introducing themselves. People constantly say, &quot;get out of the comforting zone&quot;. It&apos;s true for basically every one on earth.","link":"/2022/firstsinLife"},{"title":"Ipv6 Availability Checking Script on Padavan","text":"For some unknown reasons, the ipv6 got offline once in a while. After rebooting, it turned just fine. I need ipv6 to do torrenting. So here comes the demand for a script to check my ipv6 availability. 1234567891011121314#!/bin/sh#ipv6 check script, reboot if fails#url=&lt;an ipv6-only site&gt; || delete the &quot;#&quot; to take effect or replace &apos;$url&apos; with actual url down in the corresponding commandn=4timeout=1000logger -t &quot;[ipv6]&quot; &quot;check BEGIN&quot;ping -c $n -W $timeout $urlif [ $? != 0 ];then logger -t &quot;[ipv6]&quot; &quot;failed, try reboot&quot; rebootelse logger -t &quot;[ipv6]&quot; &quot;working fine!&quot;fiexit 0 What it does is obvious. Noted that logger -t needs two strings to display information in the log area. The script above displays information as follows. 12Oct 21 17:40:00 [ipv6]: check BEGINOct 21 17:40:03 [ipv6]: working fine However, the log area could be filled with these two information, which is not ideal. logger -t sentence could be deleted after testing. #Settings Check Advanced settings-System settings-Services-Enable SSH. SSH might not work properly on windows due to some reason about porting. Open the corresponding ports on windows should be the solution here. 1ssh admin@192.168.123.1 Change directory to /etc/storage/. Files in other directories will be deleted after rebooting. We don&apos;t want our script to vanish, of course. vi ipv6_check.sh. Create a .sh script, and save the code above inside. The operations of vi is somewhat different from how we operate on windows. The script is not written into the ROM if you did not run the mtd_storage script, because of some settings of Padavan firmware. run /sbin/mtd_storage.sh save to save the modification. Run script regularly. system settings-Services-cron Input */10 * * * * /etc/storage/ipv6_check.sh in the Cron tab to run the script every 10 minutes.","link":"/2021/ipv6"},{"title":"Manipulate Microsoft Excel with Python","text":"Just some script used at work, mainly about inserting pictures into Excel sheets.Below are something might be useful for other tasks. #Open file &amp; Switch to sheet* The library used here is xlwings Note that the file name and the sheet name should both be in string format. 123import xlwings as xwwb = xw.Book(&quot;main.xlsx&quot;)sht = wb.sheets[&quot;sheet1&quot;] #Insert pictures into cellsThe function is quite easy to find in the official documentation. Actually if you&apos;ve got the patience to read the document or even search for things relevant for a while, things I write in this post are just garbage. ^.^ 1add(image, link_to_file=False, save_with_document=True, left=None, top=None, width=None, height=None, name=None, update=False, scale=None, format=None, anchor=None, export_options=None) #Find cellWe can tell from the function above that in order to insert a picture, we need to know the left and top position of the target cell. The very first thing to be clear is that in Excel, pictures are not on the same layer as cells or texts inside of cells. So when I say &quot;inserting&quot;, I actually mean &quot;paste&quot; a picture onto the given position. Now the question is, what is the position? 12cell = sht.range(&quot;B1:F2&quot;)topPos, leftPos = cell.top, cell.left Simple as that. One thing only. If the target cell is a merged cell, put the full range inside sht.range() method. -&gt; link #ResizeWhen inserting a specific image file into cells, it&apos;s rather common that the sizes don&apos;t match. Resizing is a must here, well for me at least. You can simply resize the picture into the target cell size, in spite of the aspect ratio. Or you can scale the picture up or down to match the cell size and keep the aspect ratio as it is. Either way, sizes, are needed, for both cell and image. 1cellW, cellH = cell.width, cell.height As for image size, there&apos;re millions of ways to get access to it. #Insert text into cellsCompared with inserting images, inserting text is way easier. 1sht.range(f&quot;{cell_range}&quot;).value = f&quot;{your_text}&quot; Voila! #EndingYeah, don&apos;t forget to save and close the Excel file in the end. Or just save the file so as to make sure pictures are placed just fine. 12wb.save()wb.close()","link":"/2022/officeExcelWithPython"},{"title":"Mini Tools that Make Daily Works Simple","text":"Constantly ran into some redundant works lately, like renaming folders/files, modifying file properties, etc. Hence, these mini tools. Well, I&apos;m no good at .bat scripts. Which, doesn&apos;t require basically anything, and is much easier to use. #Find all files in the folder And files in sub-folder, sub-sub-folder,... 12345678910def all_files_path(root_dir): filepaths = [] for root,dirs,files in os.walk(root_dir): for file in files: file_path = os.path.join(root,file) filepaths.append(file_path) for dir in dirs: dir_path = os.path.join(root,dir) all_files_path(dir_path) return filepaths The return value of the function above is a list of strings which contain the full path of the files under folder root_dir. With this function, there&apos;re so many stuff you get to do. For example, to delete all .un~ files under the current folder, simply pick all strings ending with &apos;.py~&apos;, then use os.unlink to delete corresponding files. With regular expressions, there&apos;re even more fun stuffs you can do. #Deleting EXIF informationEXIF may contain a lot of sensitive information such as where and when the picture was taken, what kind of camera was used, plus even detailed parameters of a picture, ISO, aperture, etc. Therefore deleting EXIF information is widely suggested before uploading pictures to the internet or sending pictures to other people, even the people you know. Below I&apos;ll use only .jpg files to demonstrate how it&apos;s done. 1234567from pyexiv2 import Imageimport jsonimg = Image(f&quot;{imgFileName}&quot;)exif = img.read_exif()with open(f&quot;{jsonFileName}&quot;, &apos;w&apos;) as f: json.dump(exif, f, indent=2) {&quot;Exif.Image.Make&quot;: &quot;Canon&quot;,&quot;Exif.Image.Model&quot;: &quot;Canon EOS 800D&quot;,&quot;Exif.Image.Orientation&quot;: &quot;1&quot;,&quot;Exif.Image.XResolution&quot;: &quot;72/1&quot;,&quot;Exif.Image.YResolution&quot;: &quot;72/1&quot;,&quot;Exif.Image.ResolutionUnit&quot;: &quot;2&quot;,&quot;Exif.Image.DateTime&quot;: &quot;2018:09:12 15:15:50&quot;,...} Basically, EXIF is stored in the shape of a dictionary. Modifying all the values to whatever don&apos;t make any sense would just do the trick. 1234567891011121314from pyexiv2 import Imagedef all_files_path(root_dir): # still remember this function, do you? ...if __name__ == &quot;__main__&quot;: all_files_path(os.getcwd()) for filepath in filepaths: if filepath.endswith(&quot;.JPG&quot;) or filepath.endswith(&quot;.jpg&quot;): img = Image(filepath) exif = img.read_exif() for i in exif: exif[i] = &quot;&quot; img.modify_exif(exif) If you read the exif information now, it is gonna be like below. {&quot;Exif.Image.Make&quot;: &quot;&quot;,&quot;Exif.Image.Model&quot;: &quot;&quot;,&quot;Exif.Image.Orientation&quot;: &quot;&quot;,&quot;Exif.Image.XResolution&quot;: &quot;&quot;,&quot;Exif.Image.YResolution&quot;: &quot;&quot;,&quot;Exif.Image.ResolutionUnit&quot;: &quot;&quot;,&quot;Exif.Image.DateTime&quot;: &quot;&quot;,...} #AfterwordMore yet to come. =.=","link":"/2022/miniTools"},{"title":"Python Challenge Notes (Part 1)","text":"Just some notes，http://www.pythonchallenge.com/Complete source code here #Contents Level 1 Level 2 Level 3 Level 4 Level 5 Level 6 Level 7 Level 8 Level 9 Level 10 Level 11 Level 12 Level 13 Level 14 Level 15 Level 16 Level 17 Level 18 Level 19 Level 20 #Level 0238=274877906944 Change the url to http://www.pythonchallenge.com/pc/def/274877906944.html，and there comes Level 1. #Level 1Obviously, by adding an offset to the ascii of each letter in the sentence you&apos;ll get the instruction. 12345678910line = &quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&apos;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;list1 = []for i in list(line): if i.isalpha(): j = ord(i)+2 s = chr(j) if j&lt;123 else chr(j-26) else: s = i list1.append(s)print(&quot;&quot;.join(list1)) The output i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that&apos;s why this text is so long. using string.maketrans() is recommended. now apply on the url. OK, apply to the url map, and the url for level 2 is here. Noted that it mentioned str.maketrans() function, which is not how I solved the problem. So what does maketrans() do? Here is the official documentation. In short, it generates a translating method. str.translate() function then uses this method to translate a giving string. Now let&apos;s try this out. 12345line = &quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&apos;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;label1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;label2 = &quot;cdefghijklmnopqrstuvwxyzab&quot;trans = str.maketrans(label1, label2)print(line.translate(trans)) i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that&apos;s why this text is so long. using string.maketrans() is recommended. now apply on the url. OK, exactly what we expected. #Level 2It&apos;s evident that we should take a look at the source code of the page. There&apos;s a comment: find rare characters below. For convenience, save all those charactors to assets/txt_for_2.txt, and find out the occurrence of each charactor. 123456from collections import Counterwith open(&quot;assets/txt_for_2.txt&quot;, &quot;r&quot;) as f: string = f.read()count = Counter(string)print(count) Counter({&apos;)&apos;: 6186, &apos;@&apos;: 6157, &apos;(&apos;: 6154, &apos;]&apos;: 6152, &apos;#&apos;: 6115, &apos;_&apos;: 6112, &apos;[&apos;: 6108, &apos;}&apos;: 6105, &apos;%&apos;: 6104, &apos;!&apos;: 6079, &apos;+&apos;: 6066, &apos;$&apos;: 6046, &apos;{&apos;: 6046, &apos;&amp;&apos;: 6043, &apos;*&apos;: 6034, &apos;^&apos;: 6030, &apos;\\n&apos;: 1219, &apos;e&apos;: 1, &apos;q&apos;: 1, &apos;u&apos;: 1, &apos;a&apos;: 1, &apos;l&apos;: 1, &apos;i&apos;: 1, &apos;t&apos;: 1, &apos;y&apos;: 1}) OK, combine the charactors only show up once, and there you get the url for next level. #Level 3Again, obviously, this level demands regx. Taking a look at the source code is a must. Save those charactors to assets/txt_for_3.txt and let&apos;s go for it. 1234567import rewith open(&quot;assets/txt_for_3.txt&quot;, &quot;r&quot;) as f: line = f.read()reg=re.compile(&apos;[a-z][A-Z]{3}[a-z][A-Z]{3}[a-z]&apos;)url = reg.findall(line)for u in url: print(u[4], end=&apos;&apos;) And the output is linkedlist, now change the url. The url for the next level is a little different, as it says. #Level 4Nothing on the page or in the source code. Click on the image, it leads us to a new page and says the next nothing is 44827. Change the url to ...?nothing=44827. Oh, again, the next nothing is 45439. Seems that some http library like requests is needed. 123456789import requestsurl=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345&apos;r=requests.get(url)txt=r.textwhile True: url=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=&apos;+txt.split()[-1] r=requests.get(url) txt=r.text print(txt) Wait for a reasonable output. #Level 5pronounce it. Go for source code. The image is called peakhell.jpg. And there&apos;s something didn&apos;t show up on the page. 123&lt;peakhell src=&quot;banner.p&quot;&gt;&lt;!-- peak hell sounds familiar ? --&gt;&lt;/peakhell&gt; Changing url to banner.p, there&apos;s a load of charactors making no sense at all. Back to where we started, &quot;pronounce it&quot;. There&apos;s a module called pickle which is for serializing and de-serializing. 1234567from urllib import requestimport pickleurl = &apos;http://www.pythonchallenge.com/pc/def/banner.p&apos;f = request.urlopen(url)result = pickle.load(f)print(result) The output turns out to be a two-dimensional list. Take a glance at it. The numbers in the first three lines add up to 95. There&apos;s a possibility that the number is the occurrence of the charactor in front. 1234for i in result: for j in i: print(j[0] * j[1], end = &apos;&apos;) print(&apos;\\n&apos;) The output is #Level 6zip Change the url to *.zip and we get a file channel.zip. Unzip it, there&apos;s a readme.txt. Well, it&apos;s similar to level 4. 123456789PATH = &apos;assets/channel/&apos;name = &apos;90052&apos;while True: filepath = PATH + name + &quot;.txt&quot; with open(filepath, &quot;r&quot;) as f: text = f.readline() print(text) s = text.split(&quot; &quot;) name = s[-1] NO, the program runs into an error. In the last file collect the comments. Now, what is a zip comment? Google it:A comment is optional text information that is embedded in a Zip file. -&gt;source With 7zip, we can see the comment of each file. The lengths of those comments are the same, only one charactor. Now, let&apos;s have fun with the zip file. zipfile module is needed, of course. 12345678910111213import zipfilenum = &quot;90052&quot;comments = []f = zipfile.ZipFile(&quot;assets/channel.zip&quot;) # open zip filetry: while True: filepath = num + &quot;.txt&quot; line = f.read(filepath).decode(&quot;utf-8&quot;) # read txt file inside comment = f.getinfo(filepath).comment.decode(&quot;utf-8&quot;) # comment of txt file num = line.split(&quot; &quot;)[-1] comments.append(comment)except KeyError: print(&quot;&quot;.join(comments)) Replace the url with hockey. It says it&apos;s in the air. look at the letters. Well, ya know what to do. #Level 7Just a picture, nothing in the source code. The information has to be in the picture, then. Noted there&apos;s a horizontal line which does not fit the picture at all. By observing the line pixel by pixel with Snipaste, we can find out that the color turns different every 7-9 pixels. 123456789101112131415161718192021222324import cv2img = cv2.imread(&quot;assets/oxygen.png&quot;)offset1, offset2, offset3 = 7, 8, 9x, y, z, m = 0, 0, 0, int(img.shape[0] / 2 + 1)l1, l2, l3 = [], [], []while x &lt;= img.shape[1]: px1 = img[m, x] if px1[0] == px1[1] == px1[2]: l1.append(px1[0]) x += offset1while y &lt;= img.shape[1]: px2 = img[m, y] if px2[0] == px2[1] == px2[2]: l2.append(px2[0]) y += offset2while z &lt;= img.shape[1]: px3 = img[m, z] if px3[0] == px3[1] == px3[2]: l3.append(px3[0]) z += offset3print(f&quot;offset = 7: {l1}&quot;)print(f&quot;offset = 8: {l2}&quot;)print(f&quot;offset = 9: {l3}&quot;) offset = 7: [115, 109, 97, 114, 116, 32, 103, 117, 121, 44, 32, 121, 111, 117, 32, 109, 97, 100, 101, 32, 105, 116, 46, 32, 116, 104, 101, 32, 110, 101, 120, 116, 32, 108, 101, 118, 101, 108, 32, 105, 115, 32, 91, 49, 48, 53, 44, 32, 49, 49, 48, 44, 32, 49, 49, 54, 44, 32, 49, 48, 49, 44, 32, 49, 48, 51, 44, 32, 49, 49, 52, 44, 32, 49, 48, 53, 44, 32, 49, 49, 54, 44, 32, 49, 50, 49, 93]offset = 8: [115, 109, 97, 114, 116, 103, 117, 121, 44, 32, 121, 111, 32, 109, 97, 100, 101, 32, 105, 46, 32, 116, 104, 101, 32, 110, 120, 116, 32, 108, 101, 118, 101, 32, 105, 115, 32, 91, 49, 48, 44, 32, 49, 49, 48, 44, 32, 49, 54, 44, 32, 49, 48, 49, 32, 49, 48, 51, 44, 32, 49, 52, 44, 32, 49, 48, 53, 44, 49, 49, 54, 44, 32, 49, 50, 93]offset = 9: [115, 109, 97, 116, 32, 103, 121, 44, 32, 121, 117, 32, 109, 100, 101, 32, 105, 46, 32, 116, 101, 32, 110, 101, 116, 32, 108, 118, 101, 108, 32, 115, 32, 91, 48, 53, 44, 32, 49, 48, 44, 49, 49, 54, 44, 49, 48, 49, 32, 49, 48, 51, 32, 49, 49, 44, 32, 49, 48, 44, 32, 49, 54, 44, 32, 49, 49, 93] Translate these numbers as ascii code 123456s1 = [chr(i) for i in l1]s2 = [chr(i) for i in l2]s3 = [chr(i) for i in l3]print(f&quot;offset = 7: {&apos;&apos;.join(s1)}&quot;)print(f&quot;offset = 8: {&apos;&apos;.join(s2)}&quot;)print(f&quot;offset = 9: {&apos;&apos;.join(s3)}&quot;) offset = 7: smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]offset = 8: smartguy, yo made i. the nxt leve is [10, 110, 16, 101 103, 14, 105,116, 12]offset = 9: smat gy, yu mde i. te net lvel s [05, 10,116,101 103 11, 10, 16, 11] It&apos;s obvious that result under offset=7 makes sense. Now do the same thing to the numbers in the result. #level 8There&apos;s a link on the body of the bee. And it leads us to a site which requires logging in. Source code! of course. 12un: &apos;BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084&apos;pw: &apos;BZh91AY&amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13&lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08&apos; un stands for user name, pw for password, of course. These charactors are compressed by bzip2. Let&apos;s de-compress it. 123456import bz2l1 = b&apos;BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084&apos;l2 = b&apos;BZh91AY&amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13&lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08&apos;print(bz2.decompress(l1))print(bz2.decompress(l2)) b&apos;huge&apos;b&apos;file&apos; #Level 9The page is called connect the dots, and there lies an interesting comment, first+second=? followed by a bunch of numbers. Maybe these numbers are coordinates? 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npimg = cv2.imread(&quot;assets/good.jpg&quot;)first = [146,399,163,403,170,393,169,391,166,386,170,381,170,371,170,355,169,346,167,335,170,329,170,320,170,310,171,301,173,290,178,289,182,287,188,286,190,286,192,291,194,296,195,305,194,307,191,312,190,316,190,321,192,331,193,338,196,341,197,346,199,352,198,360,197,366,197,373,196,380,197,383,196,387,192,389,191,392,190,396,189,400,194,401,201,402,208,403,213,402,216,401,219,397,219,393,216,390,215,385,215,379,213,373,213,365,212,360,210,353,210,347,212,338,213,329,214,319,215,311,215,306,216,296,218,290,221,283,225,282,233,284,238,287,243,290,250,291,255,294,261,293,265,291,271,291,273,289,278,287,279,285,281,280,284,278,284,276,287,277,289,283,291,286,294,291,296,295,299,300,301,304,304,320,305,327,306,332,307,341,306,349,303,354,301,364,301,371,297,375,292,384,291,386,302,393,324,391,333,387,328,375,329,367,329,353,330,341,331,328,336,319,338,310,341,304,341,285,341,278,343,269,344,262,346,259,346,251,349,259,349,264,349,273,349,280,349,288,349,295,349,298,354,293,356,286,354,279,352,268,352,257,351,249,350,234,351,211,352,197,354,185,353,171,351,154,348,147,342,137,339,132,330,122,327,120,314,116,304,117,293,118,284,118,281,122,275,128,265,129,257,131,244,133,239,134,228,136,221,137,214,138,209,135,201,132,192,130,184,131,175,129,170,131,159,134,157,134,160,130,170,125,176,114,176,102,173,103,172,108,171,111,163,115,156,116,149,117,142,116,136,115,129,115,124,115,120,115,115,117,113,120,109,122,102,122,100,121,95,121,89,115,87,110,82,109,84,118,89,123,93,129,100,130,108,132,110,133,110,136,107,138,105,140,95,138,86,141,79,149,77,155,81,162,90,165,97,167,99,171,109,171,107,161,111,156,113,170,115,185,118,208,117,223,121,239,128,251,133,259,136,266,139,276,143,290,148,310,151,332,155,348,156,353,153,366,149,379,147,394,146,399]second = [156,141,165,135,169,131,176,130,187,134,191,140,191,146,186,150,179,155,175,157,168,157,163,157,159,157,158,164,159,175,159,181,157,191,154,197,153,205,153,210,152,212,147,215,146,218,143,220,132,220,125,217,119,209,116,196,115,185,114,172,114,167,112,161,109,165,107,170,99,171,97,167,89,164,81,162,77,155,81,148,87,140,96,138,105,141,110,136,111,126,113,129,118,117,128,114,137,115,146,114,155,115,158,121,157,128,156,134,157,136,156,136]pts1 = np.array(first, np.int32)pts1 = pts1.reshape((-1,2))pts2 = np.array(second, np.int32)pts2 = pts2.reshape((-1,2))cv2.polylines(img,[pts1, pts2],True,(0,255,255))cv2.imshow(&quot;img&quot;, img)cv2.waitKey(0) Fact is, we do not need the image good.jpg. A blank picture works just fine. 1img = np.zeros((512,512,3), np.uint8) There it comes. The answer lies in cow/bull/ox/cattle. Take your shots. #Level 10There&apos;s a link on the body of the cow. It&apos;s a list which has no end, for now. a = [1, 11, 21, 1211, 111221,. I didn&apos;t know what this list is. Google 1, 11, 21, 1211, 111221, it&apos;s called Look-and-say sequence. Now, we know what it is, the problem is simple. 123456789101112131415161718a = [&apos;1&apos;]c1, c2 = &apos;1&apos;, &apos;&apos;for _ in range(30): count, i, j = 0, 0, 0 while i &lt; len(c1): while j &lt; len(c1): if c1[i] == c1[j]: count += 1 j += 1 else: break c2 += str(count) + c1[i] i = j count = 0 a.append(c2) c1 = c2 c2 = &apos;&apos;print(len(a[30])) And the url for the next level shows. #Level 11odd even, and just a picture. Obviously, we are gonna have fun with the picture. Try splitting the picture by the odd/even of the sum of x,y of each pixel. 1234567891011121314import cv2import numpy as npimg = cv2.imread(&quot;assets/cave.jpg&quot;)x, y, _ = img.shapeimg1, img2 = np.zeros((x//2,y//2,3), np.uint8), np.zeros((x//2,y//2,3), np.uint8)for i in range(x): for j in range(y): if (i+j)%2 == 1: img1[i//2][j//2] = img[i][j] else: img2[i//2][j//2] = img[i][j]cv2.imshow(&quot;odd&quot;, img1)cv2.imshow(&quot;even&quot;, img2)cv2.waitKey(0) The url for the next level lies in the &quot;even&quot; picture. #Level 12dealing evil. What do you mean? The picture is called evil1.jpg. Maybe there&apos;re pictures called evil2, evil3 maybe even evil4, evil5. evil2.jpg, it says not jpg, _.gfx What is a .gfx file? Google it!The GFX file type is primarily associated with Cue Club Image File. -&gt;sourceAh, it&apos;s also a image file. Go on, evil3.jpg. OK, it says no more evils. The information has to be in the evil2.gfx and evil1.jpg then. FYI: You need to try evil4 and evil5, for problems after. Open evil2.gfx, and convert it directly to evil2.jpg 1234with open(&quot;assets/evil2.gfx&quot;, &quot;rb&quot;) as f: text = f.read()with open(&quot;assets/evil2.jpg&quot;, &quot;wb&quot;) as f: f.write(text) Well, it doesn&apos;t work. OH, &quot;dealing&quot; cards. Maybe we should split the evil2.gfx into several files. Try to split it into 2 files all the way to 5 files. And finally some visible image. The answers are in the pictures. 12345with open(&quot;assets/evil2.gfx&quot;, &quot;rb&quot;) as f: text = f.read()for i in range(5): with open(f&apos;assets/{i}.jpg&apos;, &apos;wb&apos;) as f: f.write(text[i::5]) Wait, what does evil1.jpg do? Well, all the cards are 5, could be a hint I ignored... #Level 13Click on button 5, and we get a xml file. To be honest, I know nothing about this problem. I had to look for solutions online. Here are something I learned during the search. xml-rpc is a POST request in the form of xml. The response is also in the form of xml. There&apos;re xmlrpc.client and xmlrpc.server modules in python to perform these kinds of task. As the name indicates, xmlrpc.client is what we need for this problem. 123import xmlrpc.clientpost = xmlrpc.client.ServerProxy(&quot;http://www.pythonchallenge.com/pc/phonebook.php) First construct a ServerProxy subject, then use system.listMethods method to list all the methods this server provides. 1print(post.system.listMethods()) [&apos;phone&apos;, &apos;system.listMethods&apos;, &apos;system.methodHelp&apos;, &apos;system.methodSignature&apos;, &apos;system.multicall&apos;, &apos;system.getCapabilities&apos;] Among these, phone seems like a unique method of this server, use system.methodHelp to display its description 1print(post.system.methodHelp(&quot;phone&quot;)) Returns the phone of a person OK now, we&apos;ve known which method to use. The only condition left is the person. According to some online solutions, there is some information in evil4.jpg. I was too naive to trust its saying. However, because the site was constructed a long while age, only IE browser could get access to this page. We can use curl to read the page. The output indicates this person should be &quot;Bert&quot;. So we &quot;phone&quot; Bert. 1print(post.phone(&quot;Bert&quot;)) 555-ITALY #Level 14&quot;Walk around&quot;, and a picture. Maybe this problem has something to do with circles or spirals. The bar(?) picture should be the picture that we should deal with. Don&apos;t forget the comment of the page remember: 100*100 = (100+99+99+98) + (... Noted the information of this wire.png in DevTools: Rendered size:100 × 100 pxRendered aspect ratio:1∶1Intrinsic size:10000 × 1 pxIntrinsic aspect ratio:10000∶1File size:15.9 kBCurrent source:http://www.pythonchallenge.com/pc/return/wire.png Although it was displayed in the size of 100px*100px, the picture is actually in the size of 10000px*1px. What is the equation then? For example, here&apos;s a picture of 5px*5px. When you walk from the outside of it, and spirally inside, as shown below. the &quot;steps&quot; you take until you make a turn is 5,4,4,3,3,2,2,1,1 Now, let&apos;s try 100px*100px, the equation can be deducted. 100*100 = 100+99+99+98+98+97+97+...+3+3+2+2+1+1=（100+99+99+98)+(98+97+97+96)+...+(5+4+4+3)+(3+2+2+1)+1 So, the solution is to put every pixel of wire.png into a 100px*100px image &quot;spirally&quot;. 1234567891011121314151617181920import cv2import numpy as npimg = cv2.imread(&quot;assets/wire.png&quot;)img1 = np.zeros((300, 300, 3), np.uint8)img1.fill(200)dirs = [(0,1), (1,0), (0,-1), (-1,0)]count, i, pos_x, pos_y = 200, 0, -1, 0dis = count//2while dis &gt; 0: for dir in dirs: dis = count//2 for _ in range(dis): pos_x = pos_x + dir[0] pos_y = pos_y + dir[1] img1[pos_x, pos_y] = img[0, i] i += 1 count -= 1cv2.imshow(&quot;result&quot;, img1)cv2.waitKey(0) Voila~. try cat.html. Oh, he&apos;s Uzi. #Level 15I&apos;m gonna say it out directly. The musician Mozart. Why? Look at the comment. todo: buy flowers for tomorrow So I searched for celebrities born in Jan 27th. And the first result is WOLFGANG AMADEUS MOZART. Now, although having solved the problem, we&apos;re supposed to analyze the problem as well. Jan 27th has to be a major day. Look at the bottom-right corner, there&apos;re 29 days in Feb that year. So the year 1XX6 is a leap year, Jan 1 that year is a Thursday. What&apos;s more he ain&apos;t the youngest, he is the second Then we&apos;re looking at the second nearest leap year ends with number 6. 1234567891011import calendarfront, count = 2020, 0while True: year = front + 6 if calendar.isleap(year) and calendar.weekday(year, 1, 1) == 3: count += 1 front -= 10 if count == 2: print(year) break #Level 16Let me get this straight Seems that we should align these purple blocks in a straight line? If you observe the image with Snipaste, you are gonna find out there&apos;s only one purple block in each line, and each block consists of exactly 5 pixels. Well, opencv module can&apos;t deal with .gif file. I had to spend some time learning the pillow module. First we need to find out where these blocks situated in each line. The way to do it is to find five consecutive pixels with the same value. 12345678910111213from PIL import Imageimg = Image.open(&quot;assets/mozart.gif&quot;)pixels = [img.getpixel((pos_x, 0)) for pos_x in range(img.size[0])]flag = 0for i in range(len(pixels)-5): for j in range(1, 5): if pixels[i] == pixels[i+j]: flag = 1 else: flag = 0 break if flag == 1: print(pixels[i]) 195 The value we&apos;re looking for is 195. Then we crop all the pixels in front and put them behind. 123456789from PIL import Imageimg = Image.open(&quot;assets/mozart.gif&quot;)for pos_y in range(img.size[1]): pixels = [img.getpixel((pos_x, pos_y)) for pos_x in range(img.size[0])] flag = pixels.index(195) pixels = pixels[flag:] + pixels[:flag] for pos_x in range(img.size[0]): img.putpixel((pos_x,pos_y), pixels[pos_x])img.show() What is the answer? #Level 17The bottom-left corner seems familiar. Yeah, it&apos;s the picture of level 4. So we&apos;re supposed to use http request modules for this one? Cookies, what&apos;s in the cookies of this page? you%20should%20have%20followed%20busynothing... OK, we should replace the url ...?busynothing=12345 then. Well, not exactly. All we got is a that&apos;s it. That&apos;s probably the end point of the request session. Maybe we should look at the cookies during this session as well? 12345678910111213141516import reimport requestsurl=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=12345&apos;r=requests.get(url)txt=r.textcookies = r.cookies[&apos;info&apos;]while True: url=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=&apos;+txt.split()[-1] r=requests.get(url) txt = r.text print(txt) cookies += r.cookies[&apos;info&apos;] result = re.search(&apos;the next busynothing is (\\d+)&apos;, txt) if result == None: breakprint(cookies) BZh91AY%26SY%94%3A%E2I%00%00%21%19%80P%81%11%00%AFg%9E%A0%20%00hE%3DM%B5%23%D0%D4%D1%E2%8D%06%A9%FA%26S%D4%D3%21%A1%EAi7h%9B%9A%2B%BF%60%22%C5WX%E1%ADL%80%E8V%3C%C6%A8%DBH%2632%18%A8x%01%08%21%8DS%0B%C8%AF%96KO%CA2%B0%F1%BD%1Du%A0%86%05%92s%B0%92%C4Bc%F1w%24S%85%09%09C%AE%24%90 The beginning seems like the charactors in level 8, ignoring the encoding. 12line = urllib.parse.unquote_to_bytes(cookies)print(line) b&apos;BZh91AY&amp;SY\\x94:\\xe2I\\x00\\x00!\\x19\\x80P\\x81\\x11\\x00\\xafg\\x9e\\xa0 \\x00hE=M\\xb5#\\xd0\\xd4\\xd1\\xe2\\x8d\\x06\\xa9\\xfa&amp;S\\xd4\\xd3!\\xa1\\xeai7h\\x9b\\x9a+\\xbf`&quot;\\xc5WX\\xe1\\xadL\\x80\\xe8V&lt;\\xc6\\xa8\\xdbH&amp;32\\x18\\xa8x\\x01\\x08!\\x8dS\\x0b\\xc8\\xaf\\x96KO\\xca2\\xb0\\xf1\\xbd\\x1du\\xa0\\x86\\x05\\x92s\\xb0\\x92\\xc4Bc\\xf1w$S\\x85\\t\\tC\\xae$\\x90&apos; Now, it looks exactly the same as bzip2 compressed content. 1print(bz2.decompress(line).decode(&quot;utf-8&quot;)) is it the 26th already? call his father and inform him that &quot;the flowers are on their way&quot;. he&apos;ll understand. call his father, and today is 26th. We are probably looking for Mozart&apos;s father. Google it! He&apos;s Leopold. Then call should be the phone method in level 13. 1234import xmlrpc.clientpost = xmlrpc.client.ServerProxy(&quot;http://www.pythonchallenge.com/pc/phonebook.php&quot;)print(post.phone(&quot;Leopold&quot;)) 555-VIOLIN Replace the url with .../violin.html. no! i mean yes! but ../stuff/violin.php. Go on. Well, the page is called it&apos;s me. What do you want? The content of the page is a portrait of Leopold Mozart. It&apos;s obvious that we should communicate with him then. Try modifying the cookies of the page. 123456import requestsurl = &apos;http://www.pythonchallenge.com/pc/stuff/violin.php&apos;headers = {&apos;Cookie&apos;:&apos;info=the flowers are on their way&apos;}r = requests.get(url, headers=headers)print(r.text) And we get the result of 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;it&apos;s me. what do you want?&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;br&gt;&lt;br&gt; &lt;center&gt;&lt;font color=&quot;gold&quot;&gt; &lt;img src=&quot;leopold.jpg&quot; border=&quot;0&quot;/&gt;&lt;br&gt;&lt;br&gt;oh well, don&apos;t you dare to forget the balloons.&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; So, balloons. Oh, replace the url for level 17 rather than the url for the portrait. #Level 18Can you tell the difference? One is darker? it is more obvious that what you might think OK, if you say so. Try luminance/brightness. There&apos;s nothing different in brightness.html. However the comment has changed a bit. maybe consider deltas.gz Replace the url. A deltas.gz file is downloaded then. We need gzip module then. 1234import gzipwith gzip.open(&apos;assets/deltas.gz&apos;, &apos;rb&apos;) as f: content = f.read().decode()print(content) A interesting output is here. There&apos;re two columns. Maybe we should find out the difference of these two columns. We need difflib module 1234567891011121314151617181920import gzip, difflibfile1, file2 = [], []with gzip.open(&apos;assets/deltas.gz&apos;, &apos;rb&apos;) as f: content = f.readline().decode() while content: file1.append(content[:53]+&apos;\\n&apos;) file2.append(content[56:]) content = f.readline().decode()diff = difflib.Differ().compare(file1, file2)l1, l2, common = [], [], []for line in diff: if line[0] == &apos;-&apos;: l1.append(line[2:-1]) elif line[0] == &apos;+&apos;: l2.append(line[2:-1]) else: common.append(line[2:-1])print(f&quot;l1: {l1}&quot;)print(f&quot;l2: {l2}&quot;)print(f&quot;common: {common}&quot;) l1: [&apos;89 50 4e 47 0d 0a 1a 0a ...]l2: [&apos;89 50 4e 47 0d 0a 1a 0a ...]common: [&apos;89 50 4e 47 0d 0a 1a 0a ...] If you are familiar with the file structure of png files, you know what to do. The first eight bytes of the result is the signature of a png file. -&gt;source Now we save the results in corresponding png files. The url, username and password lies right there. 123456789with open(&apos;assets/lvl18_1.png&apos;, &apos;wb&apos;) as f1: for line in l1: f1.write(bytes([int(o, 16) for o in line.split(&quot; &quot;) if o]))with open(&apos;assets/lvl18_2.png&apos;, &apos;wb&apos;) as f2: for line in l2: f2.write(bytes([int(o, 16) for o in line.split(&quot; &quot;) if o]))with open(&apos;assets/lvl18_3.png&apos;, &apos;wb&apos;) as f3: for line in common: f3.write(bytes([int(o, 16) for o in line.split(&quot; &quot;) if o])) #Level 19A map of India, and a email in the comment. According to the email, we&apos;re supposed to get a audio with base64 encoding. 123456import base64with open(&quot;assets/txt_for_19.txt&quot;, &quot;r&quot;) as f: content = f.read()audio = base64.b64decode(content)with open(&quot;assets/indian.wav&quot;, &apos;wb&apos;) as f: f.write(audio) All we can hear is Sorry! Try sorry.html &quot;what are you apologizing for?&quot; Doesn&apos;t seem right. There has to be something we&apos;re missing. I didn&apos;t know much of audios. This happens to be a brilliant chance to learn about wave module. 12345import wavewith wave.open(&apos;assets/indian.wav&apos;, &apos;rb&apos;) as sound: params = sound.getparams()print(params) _wave_params(nchannels=1, sampwidth=2, framerate=11025, nframes=55788, comptype=&apos;NONE&apos;, compname=&apos;not compressed&apos;) The information of the audio is clear as it says. Noted the color in the map is reversed. Ocean is usually in blue and continent in yellow. Let&apos;s try reversing the audio. 12345678import wavewith wave.open(&apos;assets/indian.wav&apos;, &apos;rb&apos;) as sound: params = sound.getparams() content = sound.readframes(sound.getnframes())with wave.open(&apos;assets/results.wav&apos;, &apos;wb&apos;) as output: output.setparams(params=params) output.writeframes(content[::-1]) Nothing we can hear in the result. Maybe reverse every frame of the audio. 12345678import wavewith wave.open(&apos;assets/indian.wav&apos;, &apos;rb&apos;) as sound: with wave.open(&apos;assets/results.wav&apos;, &apos;wb&apos;) as output: output.setparams(sound.getparams()) for i in range(sound.getnframes()): frame = sound.readframes(1) output.writeframes(frame[::-1]) &quot;you are an idiot~ ah, ah, ah, ah ... try idiot.html. Oh, it&apos;s Leopold. He says, &quot;Now you should apologize...&quot; and gives the link to the next level. OK, We have it. #Level 20Well, I have no idea what to do. Again, I learned something during searching online. The picture above are the response headers of unreal.jpg. Now if we modify the Range value in the request headers, we&apos;ll get access to files of other range. It&apos;s clear that between 0 and 30202 bytes lies unreal.jpg. Let&apos;s go on to the next section. Set Range value to bytes=30203- 12345678910import requests, base64url = &apos;http://www.pythonchallenge.com/pc/hex/unreal.jpg&apos;cred = base64.b64encode(b&quot;butter:fly&quot;)requests.auth.HTTPBasicAuth(&quot;butter&quot;, &quot;fly&quot;)headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30203-&apos;}r = requests.get(url, headers=headers)print(r.headers)print(r.content.decode()) {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;34&apos;, &apos;Content-Range&apos;: &apos;bytes 30203-30236/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 10:22:00 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}Why don&apos;t you respect my privacy? Go on. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30237-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;47&apos;, &apos;Content-Range&apos;: &apos;bytes 30237-30283/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 10:55:42 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}we can go on in this way for really long time. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30284-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;11&apos;, &apos;Content-Range&apos;: &apos;bytes 30284-30294/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 11:07:43 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}stop this! 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30295-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;18&apos;, &apos;Content-Range&apos;: &apos;bytes 30295-30312/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:22:22 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}invader! invader! 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30313-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;34&apos;, &apos;Content-Range&apos;: &apos;bytes 30313-30346/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:23:12 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}ok, invader. you are inside now. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30347-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Type&apos;: &apos;text/html; charset=UTF-8&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:23:50 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;, &apos;Content-Length&apos;: &apos;0&apos;} Nothing here. Maybe we should look for the final section. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=2123456879-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;45&apos;, &apos;Content-Range&apos;: &apos;bytes 2123456744-2123456788/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:25:37 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}esrever ni emankcin wen ruoy si drowssap eht Reverse the output. the password is your new nickname in reverse &quot;nickname&quot; should be the &quot;invader&quot; mentioned before. Hence the password should be redavni. Go forward. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=2123456743-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;32&apos;, &apos;Content-Range&apos;: &apos;bytes 2123456712-2123456743/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:26:54 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}and it is hiding at 1152983631. The required Range value is here. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=1152983631-&apos;} The output was too much. Let&apos;s take a look at the first 20 bytes of the output. The signature of file is always hiding there. 1print(r.content[:20]) {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;239733&apos;, &apos;Content-Range&apos;: &apos;bytes 1152983631-1153223363/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:30:03 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}b&apos;PK\\x03\\x04\\x14\\x00\\t\\x00\\x08\\x00;\\xa7\\xaa2\\xac\\xe5f\\x14\\xa9\\x00&apos; The PK\\x03\\x04 is the signature of a zip file. -&gt;source Then we should save the output to a zip file and try to unzip it. 12with open(&apos;assets/20.zip&apos;, &apos;wb&apos;) as f: f.write(r.content) There&apos;s a readme.txt. OK, we are in level 21 now.","link":"/2022/pythonchallenge"},{"title":"A Password Box by Python","text":"There&apos;s a boring vacation ahead. Time to start the project.Here: repository link #IntroThis is a mini-mini project. The functions are shown below. Require a key to log in Add password item App/site name Account/email address Password Adding time (auto-generate) Encrypt the password Store password item Search for password(s) By app/site name By account/email address Update/delete password item Take password item ID as the parameter Display the password item before confirming deletion. Change log in key (2022.1) Generate password. First take a number as password length, and then generate a password with letters, numbers, and symbols. Use curses module to display #Functions#Log in keyIt&apos;s easy. A key is demanded on the first launch. Double check, then hash it and store it in the database. Every time after that, simply input the key and verify to the main interface. There should be nothing popping on the screen when inputting the log in key. With getpass module： 12import getpasspwd = getpass.getpass(&quot;[PASSWROD]: &quot;) # hide input With curses.noecho() #Python Curses ModuleHere&apos;s the official documentation. Simple as that. #Encryption, Adding, Deleting, Updating and SearchingDue to the non-reversibility of hashing, another encryption method is needed. Here I shift the ascii code of the character. The offset value is the seconds value of the adding time plus 15. For decryption, shift the ascii backwards, of course. 12345678910111213141516171819202122232425# offset functions。 only one is enough actually, with changing offset valuedef enascii(num: int, offset: int) -&gt; int: if num - offset &gt;= 33: return num - offset else: return 93 + num - offsetdef deascii(num: int, offset: int) -&gt; int: if num + offset &lt;= 126: return num + offset else: return num + offset - 93# encryptiondef encrypt(psw: str, offset: int) -&gt; str: encrypt_num = [] for i in psw: encrypt_num.append(enascii(ord(i), offset + 15)) encrypted = [chr(a) for a in encrypt_num] return &quot;&quot;.join(encrypted)# decryption, s as encrypted password stringdef decrypt(s: str, offset: int) -&gt; str: pwd = [chr(deascii(ord(a), offset + 15)) for a in s] return &quot;&quot;.join(pwd) I didn&apos;t hide the input when adding password. Some passwords might be complicated. Input them multiple times could be a pain in the **. When adding password, the box searches for duplicated password items in the database. If there&apos;s a password item with the same site/app name and account/email address, the box offers a chance to update password item rather than adding a duplication. It was hard to use Regx in sqlite3. There&apos;s a good solution in StackOverflow which I found suitable for the box. 1reg = re.compile(expr, re.I) What&apos;s left are just database operations. 1234567891011121314import sqlite3db = sqlite3.connect(&quot;database.db&quot;)cur = db.cursor()cur.execute() # commands hereresult1 = cur.fetchall()result2 = cur.fetchone()db.commit()db.close()create_command = &quot;&quot;&quot;CREATE TABLE (table) ...&quot;&quot;&quot;add_command = &quot;&quot;&quot;INSERT INTO (table) (cols) VALUES (value)&quot;&quot;&quot; # value must be tuple typeselect_command = &quot;&quot;&quot;SELECT * FROM (table) WHERE ...&quot;&quot;&quot;update_command = &quot;&quot;&quot;UPDATE (table) SET ... WHERE ...&quot;&quot;&quot;delete_command = &quot;&quot;&quot;DELETE FROM (table) WHERE ...&quot;&quot;&quot; #To DoSome are mentioned above. Here&apos;re something else. GUI Used curses instead. Use Regx when searching DOne Offer a chance when adding a duplication Interface optimizing","link":"/2021/pswbox"},{"title":"Xpath Notes","text":"It&apos;s been a while. #RequirementsBeen working on some data collection stuff lately. To locate elements in html page, xpath is very convenient. It&apos;s easy to learn as well. Simply puts, regarding html page as an element tree, xpath is just like a map telling you what to do at each or major branches. We know what the source code of a html page looks like, don&apos;t we? To use xpath in python, module lxml is needed. 123import requestsfrom lxml import etreehtml_page = etree.HTML(requests.get(url).text) Then simply using html_page.xpath(f&quot;{xpath_expression}&quot;) would easily locate the corresponding elements. #More about xpathYeah, to locate elements is just like that. However, xpath expression is a little more complex. There&apos;s a very detailed tutorial on w3schools about xpath syntax. Basically everything you need to get familiar to xpath is in it. What I wanna write about here is something I learnt during my element locating experience. To locating elements by name AND order is not available, at least for now. For example, to locate the text go, the xpath expression would be &apos;//div[@class=&quot;main&quot;]/div[5]/p/text()&apos;, which means the fifth div under main div. To express the third div under the main div with a class name of &quot;h&quot; is not possible. 1234567&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;h&quot;&gt;&lt;p&gt;He&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;j&quot;&gt;&lt;p&gt;and&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;J&quot;&gt;&lt;p&gt;I&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;h&quot;&gt;&lt;p&gt;will&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;h&quot;&gt;&lt;p&gt;go&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; Well, not that hard you may say. What if there&apos;re hundreds of div&apos;s under the main div. When you get to work with real html pages, it&apos;s very rare to find distinct snippets like above. So, find other ways to locate elements when you trying to do it by name and order at the same time. Most web browser has its direct ways to copy xpath. For example, in Microsoft Edge simply press F12 to enter devTools. Right click corresponding source code then there is a copy-&gt;copy xpath selection. However, if you use requests to get a page, the source code is A LITTLE different to what&apos;s shown in devTools. You can find a load of information on the internet about why there&apos;re differences. Maybe using POST method? I&apos;ll give it try later. No tutorial could ever teach you everything about it. Gonna have to try things when it comes to real problems. Sometimes you need to locate elements one by one even if they are perfectly aligned in html viewer like web browser. Be patient. In the case of new problems, of course.","link":"/2022/xpathNotes"},{"title":"Python Challenge Notes (Part 2)","text":"Again, just some notesComplete source code here #Contents Level 21 Level 22 Level 23 Level 24 Level 25 Level 26 Level 27 Level 28 Level 29 Level 30 Level 31 Level 32 Level 33 #Level 21 Yes! This is really level 21 in here.And yes, After you solve it, you&apos;ll be in level 22! Now for the level: We used to play this game when we were kids When I had no idea what to do, I looked backwards. There&apos;s this package.pack file inside the zip. First open it in HEX, maybe the file header is familiar. 123with open(&quot;assets/21/package.pack&quot;, &apos;rb&apos;) as f: data = f.read()print(data[:20].hex()) 789c000a40f5bf789c000740f8bf789c000640f9 78 9c is very likely file header of a zlib file. -&gt; source Now decompress the data variable with zlib. 1234import zlib...data = zlib.decompress(data)... 789c000740f8bf789c000640f9bf789c00ff3f00 Again, 78 9c. Maybe it&apos;s a file compressed multiple times. 123456789import zlibwith open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) else: breakprint(data[:20].hex()) 425a683931415926535991e82f2b0076a97fffff Now, 42 5a. It&apos;s bzip compressed file. -&gt; source 1234567891011import zlib, bz2with open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) elif data[:2].hex() == &quot;425a&quot;: data = bz2.decompress(data) else: breakprint(data[:20].hex()) 808d96cbb572a70006587ada664f19ee846ba464 80 8d doesn&apos;t seem like any file header. Oh right, it said When I had no idea what to do, I looked backwards. 123456789101112131415import zlib, bz2with open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) elif data[:2].hex() == &quot;425a&quot;: data = bz2.decompress(data) elif data[-2:].hex() == &quot;9c78&quot;: data = zlib.decompress(data[::-1]) elif data[-2:].hex() == &quot;5a42&quot;: data = bz2.decompress(data[::-1]) else: breakprint(data[:20]) b&apos;sgol ruoy ta kool&apos; The output is &quot;look at your logs&quot; in reverse. Logs, what are logs when decompressing? I had to search for this online. Turns out, here the &quot;logs&quot; means that you&apos;re supposed to record every decompression. hahaha 12345678910111213141516171819202122import zlib, bz2from collections import Counterwith open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()logs = []while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) logs.append(&quot;*&quot;) elif data[:2].hex() == &quot;425a&quot;: data = bz2.decompress(data) logs.append(&quot;@&quot;) elif data[-2:].hex() == &quot;9c78&quot;: data = zlib.decompress(data[::-1]) logs.append(&quot;#&quot;) elif data[-2:].hex() == &quot;5a42&quot;: data = bz2.decompress(data[::-1]) logs.append(&quot;+&quot;) else: breakcount = Counter(logs)print(count) What was stored in the logs variable made no sense at all. So I used Counter to display the occurence of each charactor. Could be helpful, I thought. Counter({&apos;*&apos;: 423, &apos;@&apos;: 300, &apos;#&apos;: 9}) Seems charactor # is the separator. 123lines = &quot;&quot;.join(logs).split(&quot;#&quot;)for line in lines: print(line) The output looks like this. There you have it~ Well, as a matter of fact, it&apos;s better to use bytes format for if...elif...else conditional execution. And it saves a load of computing as well. For example the bytes format of 789c should be b&apos;x\\x9c&apos;. HEX format did help with searching for what file headers should look like, though. #Level 22Woo, what a week! Now back to the challenge The comment says &quot;or maybe white.gif would be more bright&quot;. Change the url to .../white.gif. It&apos;s a black image. Well, not exactly. With zooming in several times, a grey (or &quot;not that black&quot;) pixel around the center of the image can be noticed. And the image is actually a gif file with multiple frames, unlike mozart.gif from level 16, which, on the contrary, contains only 1 frame. First we need to know the modes of the frames. 123456from PIL import Image, ImageSequencepic = Image.open(&quot;assets/white.gif&quot;)frames = ImageSequence.Iterator(pic)for frame in frames: print(frame.mode) PRGBRGB... There you have it. The first frame is a picture of 8-bit mode. -&gt; source And the rest of it, all RGB mode So how do we find the &quot;grey pixels&quot; when the frames are in different modes? There&apos;s a ImageStat Module which can be use to calculate various statistics of a picture. Let&apos;s try it out. 1234567from PIL import Image, ImageSequence, ImageStatpic = Image.open(&quot;assets/white.gif&quot;)frames = ImageSequence.Iterator(pic)for frame in frames: stat = ImageStat.Stat(frame) print(stat.extrema) [(0, 8)][(0, 8), (0, 8), (0, 8)][(0, 8), (0, 8), (0, 8)][(0, 8), (0, 8), (0, 8)][(0, 8), (0, 8), (0, 8)]... So the values of &quot;grey pixels&quot; come in two different ways, 8 and (8, 8, 8). Now let&apos;s get the coordinates of the &quot;grey pixels&quot;. 123456789101112131415161718192021from PIL import Image, ImageSequencepic = Image.open(&quot;assets/white.gif&quot;)frames = ImageSequence.Iterator(pic)coords = []for frame in frames: for n_y in range(frame.size[1]): pixels = [frame.getpixel((n_x, n_y)) for n_x in range(frame.size[0])] try: pos_x = pixels.index(8) pos_y = n_y coords.append([pos_x, pos_y]) break except ValueError: try: pos_x = pixels.index((8, 8, 8)) pos_y = n_y coords.append([pos_x, pos_y]) except ValueError: passprint(coords) Variable coords is a two dimensional list, and its length is 133. The white.gif itself contains 133 frames as well. Seems we&apos;ve gotten all the coordinates. Now let&apos;s take a deep look at the list. All the values are within 2px distance to (100, 100). And value (100, 100) shows up relatively fewer times. Oh, don&apos;t forget about the picture in copper.html, it&apos;s something like a joystick. Maybe the coordinates represent directions. 1234567891011newpic = Image.new(&quot;1&quot;, (1000, 100))px = py = 0for coord in coords: x = coord[0] - 100 y = coord[1] - 100 if x == y == 0: x += 100 px += x py += y newpic.putpixel((px, py), 1)newpic.show() And now we get the url for the next level. #Level 23A bull. Page title is what is this module?. And some text in the source code. TODO: do you owe someone an apology? now it is a good time totell him that you are sorry. Please show good manners althoughit has nothing to do with this level.----------it can&apos;t find it. this is an undocumented module.&apos;va gur snpr bs jung?&apos; Remember? In the end of level 19, we get a portrait of Leopold Mozart. And he says, &quot;Now you should apologize&quot;. Maybe now is the time we say sorry. Well, after trying for some times, I realized that it&apos;s being serious this time. It does have nothing to do with this level. So let&apos;s focus on what&apos;s left here. Seems that &apos;va gur snpr bs jung&apos; should be a instruction. &quot;What is this module?&quot; If you are familiar with python, you&apos;ll know there&apos;s a famous poem called &quot;The Zen of Python&quot;. You can get the poem simply by running import this. Here the module name is exactly &quot;this&quot;. Coincidence? And if you open this.py which is in the python lib folder. You&apos;ll see the poem itself is not stored as it shows. 12345678910111213141516171819202122232425262728s = &quot;&quot;&quot;Gur Mra bs Clguba, ol Gvz CrgrefOrnhgvshy vf orggre guna htyl.Rkcyvpvg vf orggre guna vzcyvpvg.Fvzcyr vf orggre guna pbzcyrk.Pbzcyrk vf orggre guna pbzcyvpngrq.Syng vf orggre guna arfgrq.Fcnefr vf orggre guna qrafr.Ernqnovyvgl pbhagf.Fcrpvny pnfrf nera&apos;g fcrpvny rabhtu gb oernx gur ehyrf.Nygubhtu cenpgvpnyvgl orngf chevgl.Reebef fubhyq arire cnff fvyragyl.Hayrff rkcyvpvgyl fvyraprq.Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&apos;er Qhgpu.Abj vf orggre guna arire.Nygubhtu arire vf bsgra orggre guna *evtug* abj.Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg&apos;f n onq vqrn.Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg&apos;f qb zber bs gubfr!&quot;&quot;&quot;d = {}for c in (65, 97): for i in range(26): d[chr(i+c)] = chr((i+13) % 26 + c)print(&quot;&quot;.join([d.get(c, c) for c in s])) It requires shifting the ascii value of a letter to translate. Now we apply the same method to &apos;va gur snpr bs jung&apos; 123456s = &apos;va gur snpr bs jung&apos;d = {}for c in (65, 97): for i in range(26): d[chr(i+c)] = chr((i+13) % 26 + c)print(&quot;&quot;.join([d.get(c, c) for c in s])) in the face of what The answer is in the poem. Find it yourself~ #Level 24Page title is &quot;From top to bottom&quot;. And the picture name is maze.png. Path finding? A perfect chance to try BFS and DFS algorithm (maybe A* as well). If you know nothing about these two algorithm, MIT OpenCourseWare provided great lessons for both BFS and DFS algorithm. Zoom in maze.png a few times. there&apos;re only 2 black pixels in the outer circle. One is on the upper right corner, the other lower left. It&apos;s very likely that theses 2 pixels are entrance and exit. White pixels being walls, feels a little different from usual. Evem though I&apos;ve become familiar with pillow recently, I am still gonna use opencv this time. lol. First, we need the coordinates of entrance and exit. 123456789101112import cv2import numpy as npimg = cv2.imread(&quot;assets/maze.png&quot;)width, height, _ = img.shapeblack = np.array([0, 0, 0])for i in range(width): if np.array_equal(img[0][i], black): print(i)for j in range(width): if np.array_equal(img[640][j], black): print(j) 6391 Therefore the coordinates are (0, 639) and (640, 1). Let&apos;s just assume the entrance is the former one and exit the latter. #BFS AlgorithmAs for the FIFO queue used in the BFS algorithm, either Queue Module or deque class in collections module works just fine. Even a simple python list class would do the work as well. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import cv2import numpy as npdef inpic(coord): x = 0 &lt;= coord[0] &lt; 641 y = 0 &lt;= coord[1] &lt; 641 return x and ydef valid_check(coord, image, l): white = np.array([255, 255, 255]) return inpic(coord) and coord not in l and not np.array_equal(image[coord], white)def BFS(img: np.ndarray, entrance: np.ndarray, exit:np.ndarray): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue, visited = [exit], {} while queue: current = queue.pop(0) # get the head of the queue if current == entrance: break # early stop for dir in directions: pos = (current[0] + dir[0], current[1] + dir[1]) if valid_check(pos, img, visited): visited[pos] = current # link the surrounding pixels to central pixel queue.append(pos) path = [] while not np.array_equal(current, exit): path.append(current) current = visited[current] # reverse to find the path return pathif __name__ == &apos;__main__&apos;: img = cv2.imread(&quot;assets/maze.png&quot;) # width, height, _ = img.shape # black = np.array([0, 0, 0]) # for i in range(width): # if np.array_equal(img[0][i], black): # print(i) # 639 # for j in range(width): # if np.array_equal(img[640][j], black): # print(j) # 1 entrance, exit = (0, 639), (640, 1) path = BFS(img=img, entrance=entrance, exit=exit) path.append(exit) print(f&quot;First 20 coordinates:\\n{path[:20]}&quot;) print(f&quot;Last 20 coordinates:\\n{path[-20:]}&quot;) First 20 coordinates:[(0, 639), (1, 639), (2, 639), (3, 639), (4, 639), (5, 639), (6, 639), (7, 639), (8, 639), (9, 639), (10, 639), (11, 639), (11, 638), (11, 637), (11, 636), (11, 635), (12, 635), (13, 635), (14, 635), (15, 635)]Last 20 coordinates:[(637, 9), (636, 9), (635, 9), (635, 8), (635, 7), (635, 6), (635, 5), (635, 4), (635, 3), (634, 3), (633, 3), (633, 2), (633, 1), (634, 1), (635, 1), (636, 1), (637, 1), (638, 1), (639, 1), (640, 1)] Combined with maze.png, these coordinates seems like a valid path. You can print out more coordinates to inspect. #DFS Algorithm1234567891011121314151617181920def DFS_sub(img: np.ndarray, current, entrance: np.array, queue: list, visited: dict): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for dir in directions: pos = (current[0] + dir[0], current[1] + dir[1]) if valid_check(pos, img, visited): visited[pos] = current queue.append(pos) return queue, visiteddef DFS(img, entrance, exit): queue, visited, path = [exit], {}, [] while queue: current = queue.pop() if current == entrance: break queue, visited = DFS_sub(img, current, entrance, queue, visited) while not np.array_equal(current, exit): path.append(current) current = visited[current] return path #What&apos;s next?To be honest, I had no idea what to do next. So I did some search online. Turns out what really needed is not the coordinates, it&apos;s the RGB value of these pixels. To be accurate, the R(ed) value. Take 1 non-zero value in consective 2 pixels (if both are 0, then take 0), save the values in bytes format to a zip file, and voila. I didn&apos;t find information about 8075 being file header of a zip file, though. Replace the last part of the code above with below: 123456path = DFS(img=img, entrance=entrance, exit=exit)[1:] # change the function name to use different methodstofile = []for c in path: tofile.append(img[c][2])with open(&quot;assets/maze.zip&quot;, &apos;wb&apos;) as f: f.write(bytes(tofile[::2])) Inside the maze.zip file just created lies the url for the next level, with another zip file mybroken.zip which has not been used yet. #Level 25 Page title: Imagine how they soundInside the source code: can you see the waves? Open the picture in a new tab. The url of the picture is lake1.jpg. &quot;Sound&quot; it says. Replace the url, maybe with lake1.wav or lake1.mp3 or other audio file extensions. Fact is, lake1.wav is a valid file we can download. Judging from the file name, there has to be a whole lot of audio files, such as lake2, lake3, etc. 1234567891011import requestsi = 1while True: url = f&quot;http://www.pythonchallenge.com/pc/hex/lake{i}.wav&quot; r = requests.get(url, auth=requests.auth.HTTPBasicAuth(&apos;butter&apos;, &apos;fly&apos;)) if r.status_code != 200: break # break when url is invalid with open(f&quot;assets/25/lake{i}.wav&quot;, &apos;wb&apos;) as f: f.write(r.content) i += 1 There&apos;re in total 25 wav files. lake1.jpg is a jigsaw with exactly 25 pieces. Seems we are supposed to get 25 small pictures out of these wav files and put them together into a bigger picture. So what information should we extract from them? I tried the waveforms, spectrums of the files. Nothing seems rational. Again, some online search. Save each wav file into a image object, in bytes format. That&apos;s how it should be. Well, I never thought about this. Let&apos;s dive in. 1234import wavewaves = [wave.open(f&quot;assets/25/lake{i}.wav&quot;, &apos;rb&apos;) for i in range(1, 26)]for audio in waves: print(audio.getparams()) All 25 files share the same parameters. _wave_params(nchannels=1, sampwidth=1, framerate=9600, nframes=10800, comptype=&apos;NONE&apos;, compname=&apos;not compressed&apos;) Judging from the parameters, each file contains proximately 10800 bytes, which is also size of a image consists of 3600 pixels. 12345678910from PIL import Imagej = 0img = Image.new(&apos;RGB&apos;, (300, 300), 0)waves = [wave.open(f&quot;assets/25/lake{i}.wav&quot;, &apos;rb&apos;) for i in range(1, 26)]for audio in waves: tmp = Image.frombytes(&quot;RGB&quot;, (60, 60), bytes(audio.readframes(10800))) img.paste(tmp, [j%5*60, j//5*60]) j += 1img.show() And the answer is in the output. #Level 26Be a man - Apologize! In the source code: you&apos;ve got his email. Email. The only email ever was in level 19. So we are supposed to write a email rather than modifying the request headers then. However, maybe the site has lost some functions over the years. The email I wrote never got a reply. When searching for informations, I found that a reply WAS supposed to appear, inside which a md5 thumbprint was offered to help dealing with the mybroken.zip in level 24. Never mind that.Have you found my broken zip?md5: bbb8b499a0eef99b52c7f13f4e78c24bCan you believe what one mistake can lead to? It&apos;s clear that we should do some modification to mybroken.zip to get the same md5 thumbprint. As a matter of fact, if you extract files from mybroken.zip using 7-zip, the mybroken.gif inside is completely visiable, in spite of a CRC failed problem. It&apos;s &quot;Speed&quot;. I don&apos;t know about the details of how 7-zip managed to do this. But according to other solutions, only half of the image could be seen. It says &quot;one mistake&quot;. Only one byte of data is incorrect, then. Simply modify every byte of data and check the md5 thumbprint would do the trick. 1234567891011121314151617import hashlibstandard = &quot;bbb8b499a0eef99b52c7f13f4e78c24b&quot;with open(&quot;assets/maze/mybroken.zip&quot;, &quot;rb&quot;) as f: original = f.read()flag = 0for i in range(len(original)): for j in range(256): data = original[:i] + bytes([j]) + original[i+1:] if hashlib.md5(data).hexdigest() == standard: flag = 1 break if flag: breakprint(flag)with open(&quot;assets/maze/new.zip&quot;, &apos;wb&apos;) as new_file: new_file.write(data) Now the new zip file has no CRC problem. Conbined with &quot;I&apos;m missing the boat&quot;, the answer should be speedboat. #Level 27Between the tables. The picture lead to a page which requires a new set of username and password. Inside the source code: did you say gif?oh, and this is NOT a repeat of 14 The url of the picture is zigzag.jpg. Change it to zigzag.gif, and we get a greyscale image. Gee, I haven&apos;t work out a problem totally on my own since level 23. It&apos;s getting harder and harder for me to get the hints. Well, no surprises for this level. Most of the gif files are in &quot;P&quot; mode. It&apos;s a good way to save space. A color palette is required so as to display a &quot;P&quot; mode image. The value stored in each pixels are a pointer to a color in the palette. Here the key to solve to problem is the color palette. 12345from PIL import Imageimg = Image.open(&apos;assets/zigzag.gif&apos;)palette = img.getpalette()print(palette) The arrangement of values in this palette is regular. Every consective three values are the same. What we need is only one of three same values. Next thing to do is translate the pixel value to its color using palette. 1234567891011from PIL import Imageimg = Image.open(&apos;assets/zigzag.gif&apos;)palette = img.getpalette()[::3]trans = bytes.maketrans(bytes([i for i in range(256)]), bytes(palette))img_b = img.tobytes()print(f&apos;img_b first 20: {img_b[:20].hex()}&apos;)print(f&apos;img_b last 20: {img_b[-20:].hex()}&apos;)result = bytes.translate(img_b, trans)print(f&apos;result first 20: {result[:20].hex()}&apos;)print(f&apos;result last 20: {result[-20:].hex()}&apos;) img_b first 20: d7d0cb0cfe3c8b4842bd7fb0ad46aacf27207e8eimg_b last 20: 7a5f0d5b95e3b20e6a0388bf05d439b8174efa64result first 20: d0cb0cfe3c8b4842bd7fb0ad46aacf27207e8ea4result last 20: 5f0d5b95e3b20e6a0388bf05d439b8174efa645d Seems that the first 20 bytes of variable result and variable img_b are identical, except for the first byte of img_b and last byte of relsult. Are they the same all the way? 12print(len(img_b) == len(result))print(img_b[1:] == result[:-1]) TrueFalse Turns out that these two variables are identical in lenth. The content we are looking at, on the other hand, are different. Now let&apos;s compare the contents. 123456789raw, img_b = raw[1:], img_b[:-1]diff_raw = []diff_b = []for i in range(len(raw)): if raw[i] != img_b[i]: diff_raw.append(raw[i]) diff_b.append(img_b[i])print(bytes(diff_raw)[:20])print(bytes(diff_b)[:20]) b&apos;BZh91AY&amp;SY\\xe0\\xaaYF\\x00\\x17\\x9a\\x11\\x80@&apos;b&apos;\\x99\\xbdQ\\x82\\xf2\\x89S\\x04\\x15E\\x047 \\x04\\x95\\xe4N\\x9b\\xd5\\xa8&apos; The first one is a bzip compressed content obviously. The other one, no clue. 123clue1, clue2 = bytes(diff_raw), bytes(diff_b)clue1 = bz2.BZ2Decompressor().decompress(clue1)print(clue1) It&apos;s a bunch of information, one is a url, others are just words. Use set class to remove redundant words. 12l1 = clue1.decode().split(&apos; &apos;)print(set(l1)) {&apos;else&apos;, &apos;is&apos;, &apos;raise&apos;, &apos;pass&apos;, &apos;assert&apos;, &apos;while&apos;, &quot;while&apos;&quot;, &apos;yield&apos;, &apos;in&apos;, &apos;lambda&apos;, &apos;for&apos;, &apos;return&apos;, &apos;or&apos;, &apos;../ring/bell.html&apos;, &apos;exec&apos;, &apos;def&apos;, &apos;if&apos;, &apos;break&apos;, &apos;continue&apos;, &apos;not&apos;, &apos;and&apos;, &apos;import&apos;, &quot;b&apos;../ring/bell.html&quot;, &apos;switch&apos;, &apos;class&apos;, &apos;except&apos;, &apos;global&apos;, &apos;del&apos;, &apos;repeat&apos;, &apos;from&apos;, &apos;elif&apos;, &apos;try&apos;, &apos;print&apos;, &apos;finally&apos;} ../ring/bell.html is the exact url that main picture of this level pointing at. That way, the username and password should be in the set as well. Question is, which ones? If we take down the position of these differences, and make a image and change theses positions, we&apos;ll get a picture as follows. 12345678910...for i in range(len(raw)): if raw[i] != img_b[i]: diff_raw.append(raw[i]) diff_b.append(img_b[i]) pos.append(i)newimg = Image.new(&quot;1&quot;, img.size, 1)for v in pos: newimg.putpixel((v%width, v//width), 0)newimg.show() Now what&apos;s left to do is just filter python keywords outta that set earlier. 123456clue1, clue2 = bytes(diff_raw), bytes(diff_b)clue1 = bz2.BZ2Decompressor().decompress(clue1)words = set(clue1.decode().split(&apos; &apos;))for ele in words: if not keyword.iskeyword(ele): print(ele) repeatexec../ring/bell.htmlswitchprint Apparently, this level is a little out of date. Some keywords being removed in python3 could be a reason. There should be only two words left alongside a url. So, which words are not keywords in both python2 and python3? It&apos;s simple now. Useful link: keywords in python2 #Level 28Ring-Ring-Ring, say it out loud. Sounds like grin or green? First try grin.html. you are not happy - you are feeling sick. OK, then it has to be green.html. Yes, Green! What, nothing? If you take a deeper look at the main picture bell.png, there&apos;re some &quot;bands&quot; in the picture. Maybe it has something to do with the G value. 123456789import cv2import numpy as npimg = cv2.imread(&quot;assets/bell.png&quot;)height, width, _ = img.shapeb, g, r = cv2.split(img)g1 = np.reshape(g, (1, -1))[0]np.set_printoptions(threshold=np.inf)print(g1) Variable g1 stores 307200 values. And if you take a deep look at it, the differences of most consective two values are 42/-42. Do the subtraction, filter out the values 42/-42. 12345678910111213import cv2import numpy as npimg = cv2.imread(&quot;assets/bell.png&quot;)height, width, _ = img.shapeb, g, r = cv2.split(img)g1 = np.reshape(g, (1, -1))[0].astype(np.int8)g2= g1[0::2] - g1[1::2]l = []for i in g2: if i != 42 and i != -42: l.append(i)print(l) [119, -104, -111, 100, 117, 110, -110, 105, 116, -40, 41, -46, -115, 112, -108, 105, 116, 40, 41, 91, 48, -93, 32, -63] Does it remind you of something like ascii code? Well, it does for me. 1print(&quot;&quot;.join(chr(abs(j)) for j in l)) whodunnit().split()[0] ? Whodun-WHAT? First I thought it&apos;s referring to the site. In About Page of python challenge I found the site was written by Nadav Samet. Not correct. I was so so close to solving the problem totally on my own, except for a final kick. It is referring to the creator of Python!! #Level 29An interesting level. Nothing useful in both web page and source code. Well, if there&apos;re no line numbers. I use dev tools to view the source code mostly. There&apos;s nothing interesting in the source code that way. However, I&apos;ve come to loving using requests module to view the source code recently. That&apos;s where &quot;magic&quot; happens. lol 12345import requestsurl = &quot;http://www.pythonchallenge.com/pc/ring/guido.html&quot;r = requests.get(url, auth=(&quot;repeat&quot;, &quot;switch&quot;))print(r.text) There&apos;re some blank lines in the end. You can&apos;t tell any differences between these lines when they are displayed in a terminal, though. Press ctrl+u in guido.html. For other web broswers, the shortcut could be different. In microsoft edge dev, we enter a page view-source:http://www.pythonchallenge.com/pc/ring/guido.html. The source code are displayed much distinctly. Select all, you&apos;ll see the length of these blank lines are different. Yeah, we got the key! 123456import requestsurl = &quot;http://www.pythonchallenge.com/pc/ring/guido.html&quot;r = requests.get(url, auth=(&quot;repeat&quot;, &quot;switch&quot;))msg = [len(i) for i in r.text.split(&quot;\\n&quot;)[12:]]print(msg) [66, 90, 104, 57, 49, 65, 89, 38, 83, 89, 217, 194, 112, 24, 0, 0, 4, 157, 128, 96, 128, 0, 0, 128, 32, 46, 47, 156, 32, 32, 0, 49, 76, 152, 153, 6, 70, 17, 50, 104, 100, 6, 106, 85, 100, 185, 158, 198, 24, 197, 146, 82, 72, 229, 90, 34, 1, 186, 167, 128, 127, 139, 185, 34, 156, 40, 72, 108, 225, 56, 12, 0, 0] Ascii code? 1msg = [chr(len(i)) for i in r.text.split(&quot;\\n&quot;)[12:]] [&apos;B&apos;, &apos;Z&apos;, &apos;h&apos;, &apos;9&apos;, &apos;1&apos;, &apos;A&apos;, &apos;Y&apos;, &apos;&amp;&apos;, &apos;S&apos;, &apos;Y&apos;, &apos;Ù&apos;, &apos;Â&apos;, &apos;p&apos;, &apos;\\x18&apos;, &apos;\\x00&apos;, &apos;\\x00&apos;, &apos;\\x04&apos;, &apos;\\x9d&apos;, &apos;\\x80&apos;, &apos;`&apos;, &apos;\\x80&apos;, &apos;\\x00&apos;, &apos;\\x00&apos;, &apos;\\x80&apos;, &apos; &apos;, &apos;.&apos;, &apos;/&apos;, &apos;\\x9c&apos;, &apos; &apos;, &apos; &apos;, &apos;\\x00&apos;, &apos;1&apos;, &apos;L&apos;, &apos;\\x98&apos;, &apos;\\x99&apos;, &apos;\\x06&apos;, &apos;F&apos;, &apos;\\x11&apos;, &apos;2&apos;, &apos;h&apos;, &apos;d&apos;, &apos;\\x06&apos;, &apos;j&apos;, &apos;U&apos;, &apos;d&apos;, &apos;¹&apos;, &apos;\\x9e&apos;, &apos;Æ&apos;, &apos;\\x18&apos;, &apos;Å&apos;, &apos;\\x92&apos;, &apos;R&apos;, &apos;H&apos;, &apos;å&apos;, &apos;Z&apos;, &apos;&quot;&apos;, &apos;\\x01&apos;, &apos;º&apos;, &apos;§&apos;, &apos;\\x80&apos;, &apos;\\x7f&apos;, &apos;\\x8b&apos;, &apos;¹&apos;, &apos;&quot;&apos;, &apos;\\x9c&apos;, &apos;(&apos;, &apos;H&apos;, &apos;l&apos;, &apos;á&apos;, &apos;8&apos;, &apos;\\x0c&apos;, &apos;\\x00&apos;, &apos;\\x00&apos;] It&apos;s pretty clear now. Bzip compressed content. 123456import requests, bz2url = &quot;http://www.pythonchallenge.com/pc/ring/guido.html&quot;r = requests.get(url, auth=(&quot;repeat&quot;, &quot;switch&quot;))msg = [len(i) for i in r.text.split(&quot;\\n&quot;)[12:]]print(bz2.decompress(bytes(msg))) b&quot;Isn&apos;t it clear? I am yankeedoodle!&quot; Well, I was lucky this time. Didn&apos;t run into much trouble. #Level 30Source code has made it clear that we should look at yankeedoodle.csv. In it are some &quot;random&quot; values between 1 and 0, on first glimpse. 123456import numpy as npwith open(&quot;assets/yankeedoodle.csv&quot;, &quot;r&quot;) as f: data = [float(x.strip()) for x in f.read().split(&quot;,&quot;)]content = np.array([data])n = len(img[0])print(n) 7367 What if we regard these values as a picture? First we need to find the factors of 7367 123456789import mathdef resolve(n): factors = [] for i in range(2, int(math.sqrt(n))): if n % i == 0: factors.append([i, int(n/i)]) return factorsprint(resolve(n)) [[53, 139]] There&apos;s only one possibility then. The image has to be 53px*139px. 12345import cv2height, width = resolve(n)[0]content.resize((height, width))cv2.imshow(&quot;img&quot;, content)cv2.waitKey() The output is a total mess. Switch the value of height and width. 1img.resize((width, height)) This time the output reads n=str(x[i])[5]+str(x[i+1])[5]+str(x[i+2])[6]. We are supposed to transform the float numbers into some string, if I&apos;m right. 123456789with open(&quot;assets/yankeedoodle.csv&quot;, &quot;r&quot;) as f: data = [x.strip() for x in f.read().split(&quot;,&quot;)]content = np.array([data])n = len(content[0])info = []for i in range(0, n-2, 3): n = str(content[0][i])[5] + str(content[0][i+1])[5] + str(content[0][i+2])[6] info.append(n)print(info) The output is a bunch of numbers. Again, ascii code. 12345info = []for i in range(0, n-2, 3): n = chr(int(str(content[0][i])[5] + str(content[0][i+1])[5] + str(content[0][i+2])[6])) info.append(n)print(&quot;&quot;.join(info)) So, you found the hidden message.There is lots of room here for a long message, but we only need very little space to say &quot;look at grandpa&quot;, so the rest is just garbage.(some unintelligible code) Grandpa it is. #Level 31Where am I? Main picture grandpa.jpg leads to another page, possibly for the next level. It requires another set of username and password to authenticate. The comment in the source code says short break, this ***REALLY*** has nothing to do with Python OK, if you say so. Google the image. It&apos;s Ko Samui (or Koh Samui), the second largest island in Thailand. ko/samui, koh/samui, kosamui/thailand, kohsamui/thailand. Damn, finally, after four trials. The new page reads &quot;That was too easy. You are still on 31...&quot; OK, this page seems to be the real level 31. Page title: UFOs? The image name is interesting, &quot;mandelbrot&quot;. This video explains it in detail, and helps a lot with understanding mandelbrot set. Well, it&apos;s not enough just understand what a mandelbrot set is. At least, for me. I had no idea what to do next. Again, I looked for solutions online. 123456789101112def mandelbrot(size: tuple): left, top, width, height = 0.34, 0.57, 0.036, 0.027 iteration = 128 xstep, ystep = width/size[0], height/size[1] for y in range(size[1]-1, -1, -1): for x in range(size[0]): c, z = complex(left+x*xstep, top+y*ystep), complex(0, 0) for count in range(iteration): z = z**2 + c if abs(z) &gt; 2: break yield count This is how mandelbrot set should be like for this level. Don&apos;t ask me anything about the value of the z&apos;s and c&apos;s. LOL 12345img = Image.open(&quot;assets/mandelbrot.gif&quot;)print(img.size)newimg = img.copy()newimg.putdata(list(mandelbrot(img.size)))newimg.show() The image we get in this step looks pretty similiar to the mandelbrot.gif file. 12diff = [(a - b) for a, b in zip(img.getdata(), newimg.getdata()) if a != b]print(diff) The values in diff are all 16/-16. And there&apos;re 1679 values in it. Convert the variable to a 1-bit picture. The size has to be 23*73. These are the only set of factors of 1679. 123result = Image.new(&quot;1&quot;, (23, 73))result.putdata([(i &gt; 0) and 1 or 0 for i in diff])result.show() The image we get this time is the famous Arecibo message, which was sent into universe in 1974. The answer, by the way ,is arecibo. #Level 32Page title is etch-a-scetch. Seems that we&apos;re to draw something in the page A warmup.txt was mentioned in the source code. This is pretty simple. We can solve it using the page arecibo.html up.html then. You want to go up? Let&apos;s scale this up then. Now get serious and solve this. Now it&apos;s so much harder that we&apos;re not supposed to do it by hand. It&apos;s harder than I thought. I&apos;ll pause here. Got something else urgent to do... Funny story. A colleague played the exact same game the other day. So I turned to him for advice on how to solve this kind of problems. The game is called nonogram. And there&apos;re plenty of online solvers. He himself solves the problem just like I did. With some adjustment to the up.txt and *some* help of an online nonogram solver, a snake is shown on the screen pretty soon. Try snake.html. No good. python.html, yes. 123Congrats! You made it through to the smiling python.&quot;Free&quot; as in &quot;Free speech&quot;, not as in &quot;free... Well, just google it. #Level 33We&apos;re finally at the gate of the last problem, even though I did nothing about level 32. I&apos;m gonna turn back to it, I promise. Picture name beer1.jpg. Ring a bell? Of course, try beer2.jpg. It says &quot;no, png&quot;. So beer2.png then. Source code contains some hints as well. 123456&lt;!--If you are blinded by the light,remove its power, with its might.Then from the ashes, fair and square,another truth at you will glare.--&gt; A little translation, I guess: Remove the brighter pixels, resize to a square image First, we gotta know the mode of beer2.png 123from PIL import Imageimg = Image.open(&quot;assets/beer2.png&quot;)print(img.mode) L &quot;L&quot;, is (8-bit pixels, black and white) according to pillow documentation. Now remove the brighter pixels, and save the image only when the picture can be resized into squares. 123456789101112131415from PIL import Imagefrom math import sqrtimg = Image.open(&quot;assets/beer2.png&quot;)values = list(img.getdata())while True: max_value = max(values) values = [i for i in values if i != max_value] if len(values) == 0: break root = sqrt(len(values)) if root == int(root): output = Image.new(&quot;L&quot;, (int(root), int(root))) output.putdata(values) output.save(f&quot;assets/33/{int(root)}.png&quot;) We can see from the images that a different letter is appearing after 110.png. Not so clear, though. 1234567891011121314151617from PIL import Imagefrom math import sqrtimg = Image.open(&quot;assets/beer2.png&quot;)values = list(img.getdata())while True: max_value = max(values) values = [i for i in values if i != max_value] if len(values) == 0: break root = sqrt(len(values)) if root == int(root): output = Image.new(&quot;L&quot;, (int(root), int(root))) max_value = max(values) l = [255 if j == max_value else 0 for j in values] output.putdata(l) output.save(f&quot;assets/33/{int(root)}.png&quot;) Seems that letters with a box should be the answer. Try snilmerg.html. Doesn&apos;t work. Oh right! Letters should be aligned in the order as they appear. For example, 103.png appears before 98.png. So letter &quot;g&quot; should be before letter &quot;r&quot;. Hence, gremlins.html. #Final wordsSo, that&apos;s it. Wow, what a journey! I&apos;ve learnt so much from it, image processing, http requesting, file structure, etc. I&apos;ll definitely tell my friends learning python or even mastering in python to take a shot. LOL. And one last thing, I&apos;m gonna solve level 32, definitely, in a while. ^.^","link":"/2022/pythonchallenge2"}],"tags":[{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Pixel Experience","slug":"Pixel-Experience","link":"/tags/Pixel-Experience/"},{"name":"Summary","slug":"Summary","link":"/tags/Summary/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"front end","slug":"front-end","link":"/tags/front-end/"}],"categories":[{"name":"Thoughts","slug":"Thoughts","link":"/categories/Thoughts/"},{"name":"code","slug":"code","link":"/categories/code/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"router","slug":"router","link":"/categories/router/"}]}