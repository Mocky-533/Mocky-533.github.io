{"pages":[{"title":"摘抄","text":"#最好的告别 Atul Gawande 对于人类来说，生命之所以有意义乃是因为那是一个故事。一个故事具有整体感，其弧度取决于那些有意义的时刻、那些发生了重要事情的时刻。 $3/4/23$ #在中国大地上 Paul Theroux “何先生，你加入了什么工会吗？”“当然了，铁路工会，每一名铁路工人都是其中的一员。”“工会都做些什么事情？”“大家会提出一些关于工作条件的意见，也会讨论一些问题。”“会讨论钱吗？”“不会。”他回答。“如果工作条件很恶劣——比如不给你吃饭或休息的时间——或者工会的意见没有得到尊重，你们会考虑罢工吗？”沉默良久之后，何先生答道：“不会。”“为什么？英国和美国的铁路工人动不动就罢工。中国人民也有罢工的权利，宪法里有规定的。”他摸了摸下巴，变得非常严肃。“我们不为资本主义者服务，”他说，“我们服务的是人民。如果罢工的话，人们就没法出行了，那样会损害他们的利益。”“回答得很好，何先生。可是现在中国也有资本主义者了，不仅仅是那些从西方国家来的游客，中国人自己也在积累财富。”“对我来说，他们都是乘客。” $5/4/23$ #陪安东尼度过漫长岁月 Anthony(马亮) 我们为什么要旅行呢我想 可能是 因为 有些人 有些事 有些地方 一旦离开 就回不去了 或者应该说 总觉得 自己回不去了 $8/20/23$ #替这世界好好照顾自己 奥丽安·奥杜尔 他人或许不能陪在身边，但我们可以一直在自己身边，关注自己，仰赖自己，让自己活着，也让别人活着。 我们要相信自己，不管情况如何，都能缓步向前。大脑坚持前往的地方，心可能不愿去；大脑说不能去的地方，心会引领我们前行。我们要学会感受，学会思考。有时我们会受到某种莫名地指引，走上既不是心也不是大脑所选择的路径，那也不要紧，我们只要坚持聆听自己的声音，尊重自己所听到的，并给予自己所需，做应该做的。 累了就休息，渴了就喝杯水，寂寞的时候打打电话，压力大时就寻求协助。如果想要某样东西自己又负担得起，就买给自己，如果想做的事合法无害，就放手去做。这世上并没有人规定我们该爱谁或不该爱谁，以及要跟谁在一起。我们只要珍爱自己，相信自己是值得的。就像呼吸那般自然地花时间在自己身上。放手，成长，发展，专注在自身，这样当爱来临时，这份爱便能充分发展，并带来乐趣。我们值得快乐过活，不必让自己感觉罪恶——玩乐是花时间庆祝自己活着。我无法确切知道你该做些什么才能照顾自己，但我知道你一定有办法照顾自己。这就是“自我照顾”。自我照顾不是自我放纵，也不是负面诠释的利己主义，而是一种互相尊重的态度，是让我们负责任地过自己的人生，也让他人依照自己所选择的方式生活，而不仅仅是活着。 他人的怨恨是没有用的，替上帝惩罚一个人更没有必要，人们终究还是会在自己的十字架前，跌倒，战力，最终一肩扛起。而我们能做的，就是接受并原谅，然后放手让他们自己解决自己的问题。 $10/23/23$ #寻找百忧解 陈百忧 之前我有位老师曾说，善良的人才会得精神病，“因为不忍心怪别人，所以只能怪自己”。 仔细想想，需要正视磨难，与自己和解的不只是老牛。生活本就是一场持久战，老牛的选择或许是一条出路，过好自己的生活，陪伴那些你在意的人走更远的路。我很确信，往后，我们都会出现在彼此的回忆里：老牛给我们甜樱桃，我们给他力量。 如果还有机会见到王瑞军， 我很想告诉她，那个困扰你的问题可能没有标准答案，但你的存在本身，就是最好的答案。 无论我做出怎样的选择，我都希望对方能给我知情的权利——让我知晓你的一切，让后决定爱不爱你。这也该是我的权利。 我们这一生，遇到爱并不稀罕，稀罕的是——遇到了解。 $10/15/23$ #禅与摩托车维修艺术——一场对价值的探寻 Robert M. Pirsig “过去”只存在于我们的记忆中，“未来”则存在于我们的之中，而只有“现在”才是唯一的现实 $12/15/23$ 当然，试炼永远不会了结。人只要活着就会发生不愉快的事和不幸的事。但是我现在有一种以前没有过的感觉。这种感觉并不只是停留在表面，而是深入内里：我们赢了。情况正在慢慢好起来。我们几乎可以这样期许。 $12/30/23$","link":"/zh-cn/snippets/index.html"}],"posts":[{"title":"一加8T刷机(作死)历程","text":"昨天把手里的8T刷了Pixel Experience，简单记录一下遇到的几个问题。 #刷入pixel experiencePixel Experience官方的刷机教程已经比较详尽了，直接按照步骤一步步操作即可。 以下开始记录遇到的问题，其实解决方案网上搜一搜也有很多，这里记下我所用的有效的方案留个底以备用吧 进行到第四步时，执行fastboot devices查询不到设备。 首先原因为驱动未安装，在设备管理器中右键Android，依次选择更新驱动程序软件、浏览计算机以查找驱动程序软件、从计算机的设备驱动程序列表中选择、Android Phone、Android Bootloader Interface，安装好驱动，再次执行fastboot devices时就可以顺利找到设备了。 教程pre-install instructions部分提到copy-partitions-20210323_1922.zip文件无法下载 原文件所在repo中没有找到这个文件，可能是后来更改时弄错了吧。这里放一个可信的文件源，使用一切正常 PE官方提供的recovery镜像无法刷入Pixel Experience固件，手机端返回的错误码为error in /sideload/package.zip (status 1) 这个原因我也无从得知了，在xda上草草看了一眼就改用twrp recovery进行刷入了，一切正常。虽然在PE官网的固件changelog中是提到用PE的recovery进行刷入^.^ 最后一个问题纯粹是自己手贱了属于，不要回锁bootloader！ 官方教程Post-install instructions中提到了刷入 avb_custom_key后可回锁，切记切记要确认成功刷入后再回锁！昨天avb_custom_key下载失败，得到的只是一个空文件，我没有查看是否成功刷入直接进行了回锁，结果自然是一个鲜艳的红色感叹号，和那句令人窒息的&quot;your device is corrupt. It can&apos;t be trusted and will not boot&quot; 如果真的像我一样手贱回锁了，先别急，我昨天一通操作，居然进入了fastboot模式，然后又直接解锁了。 步骤如下: power+volume up彻底关机 volume down+volume up，再插入数据线，就进入fastboot模式了 这只是昨天乱尝试偶然获得的一个解决方法。如果如上操作未能顺利进入fastboot模式，建议还是稳妥起见高通9008刷机为好。 #使用中的问题 通话录音 原生安卓据说是要开始支持这一项了，不过这次刷入的PE Plus还没有这一功能，借助magisk模块Call Recorder - SKVALEX可以很好地解决这一问题。相似的解决方案也很多，不做赘述 短信拦截 这是原生安卓最大的痛点了，目前还没有太好的解决方法，待定… 取消Google Play对特定应用的更新提醒 Google Play一个我不太接受的特性就是不能忽略应用更新了。magisk的模块库中的Detach能够很好的满足这一要求。使用及操作要求在官方github仓库中有很清晰的介绍，不做赘述。需要注意的一点是，magisk安装Detach需要另一模块Busybox for Android NDK作基础，这一模块在magisk模块库中直接下载安装即可。 应用列表隐藏 也是刷机玩家的老朋友了，主要是为了避免应用读取已安装应用列表从而生成用户画像，一定程度上也是隐私保护的一种方式。 源仓库地址：github，这项功能要从LSPosed中安装，按照要求一步步下载apk安装，并从软件中安装需要的magisk模块，设定白/黑名单并将规则作用于应用即可。 更方便的联网控制 相比于安卓自带的联网控制需要一个一个软件地进行管理，利用AFWall+进行联网控制就容易且清晰得多了。这是一个可以从Google Play直接获取的应用。使用也非常直观，勾选想要限制的联网功能（局域网、WiFi、移动数据），再点击右上角应用规则即可。","link":"/2022/zh-cn/8T-flashing"},{"title":"padavan固件ipv6检验脚本","text":"不知道什么原因，ipv6总是隔一段时间就掉线，重启路由器后又恢复正常。又因为个人有pt做种需求，ipv6又是不可或缺的条件，所以写个简单的脚本，当ipv6又断线时自动重启路由器 1234567891011121314#!/bin/sh#ipv6 check script, reboot if fails#url=&lt;an ipv6-only site&gt; || delete the &quot;#&quot; to take effect or replace &apos;$url&apos; with actual url down in the corresponding commandn=4timeout=1000logger -t &quot;[ipv6]&quot; &quot;check BEGIN&quot;ping -c $n -W $timeout $urlif [ $? != 0 ];then logger -t &quot;[ipv6]&quot; &quot;failed, try reboot&quot; rebootelse logger -t &quot;[ipv6]&quot; &quot;working fine!&quot;fiexit 0 脚本内容一目了然，需要注意的一点，logger -t在log中写入信息时需要两个字符串作为输入，如上文的语句运行后在padavan管理面板的log显示如下： 12Oct 21 17:40:00 [ipv6]: check BEGINOct 21 17:40:03 [ipv6]: working fine 实际使用中，这样可能会导致log栏中的内容被以上两条占满，可以在测试实际自动运行正常后将log栏输出删除。 #操作过程 勾选高级设置-系统管理-服务-启用ssh服务，windows可能会因为端口原因无法连接，打开对应端口即可 1ssh admin@192.168.123.1 进入路由器后，要先找到/etc/storage/路径，因为其余路径在路由器重启后会自动恢复。脚本还要重复用呢是吧~ 直接用vi ipv6_check.sh命令新建脚本，将上面的内容输入保存退出即可。提醒一下vi的操作最好先熟悉熟悉。 由于padavan系统的设置，如果没有执行保存脚本，就并没有真正的写入路由器Rom里，重启之后文件还会丢失。 执行/sbin/mtd_storage.sh save保存配置。 设置定时脚本 系统管理-服务-Cron守护程序（计划任务）-Crontab中输入*/10 * * * * /etc/storage/ipv6_check.sh，设置每十分钟运行一次脚本，大功告成！","link":"/2021/zh-cn/ipv6"},{"title":"До свидания, Харбин","text":"端午前因为一些事情心情很差，想来也只是三天的短休，索性找个陌生的地方散散心，也自己思考思考 哈市，是一个多元文化汇集特征十分明显的地区，包含有多样的建筑、文化风格，只是冬季来看看冰雕，看看虎林园，一定程度上，缺少了些灵魂 #1哈尔滨老城，或许更适合找个懂建筑的人一起一条小巷一条小巷慢慢走过，听ta把每种建筑风格掰开讲来听。不懂建筑的我，只能一边看一边疯狂搜索，中华巴洛克、折衷主义、拜占庭……每个单词背后都是几百年的积淀，短时间内也只是看个皮毛，至今我仍无法准确辨别那些建筑风格的特点。 傍晚的斯大林公园确是值得一逛的地方，江边晚风虽没海风那么令人舒畅，但伴着红莓花儿开的歌声，也足够让人沉醉。只是可惜没有见到期待的拉巴扬唱莫斯科郊外的晚上的民间艺术家，不知平日里会不会有这么一道风景。不过看着相互搀扶着走上台阶的爷爷奶奶，拿着马迭尔冰棍逗孩子的奶爸奶妈，互相打打闹闹的学生……也就明白，假期的斯大林公园自然有属于假期的风景 总要在中央大街听一次整点钟声敲响吧，也算是补上一个遗憾。跨越时代的声音总能恍惚间带人回到属于它的那个时代，那个说好不算好，说坏也没那么坏的时代（我是在说些什么）。 圣·索菲亚大教堂总是说到哈尔滨绕不过的一件事，（不过我爸妈分别和我说起的第一个东西竟然都是红肠哈哈哈），那么，总要听一下教堂里的钢琴独奏吧（虽然教堂通常与管风琴搭起来效果才是一绝）。 不知道是不是老教堂上下贯通的结构的原因，任何乐器放在一间大教堂里演奏，总比舞台上的效果要好。当凤凰传奇的《荷塘月色》以钢琴曲的形式在拜占庭风格的大教堂内响起的时候，说不和谐全是假的，你能很明显地感受到人群的轻松，看到人们的惬意。出来时太阳早已不知踪迹，圣·索菲亚在灯光效果的衬托下更显另一种美，只可惜没带架子，全能靠随身小瓶支起相机简单记录下戴好了首饰——灯光的她了。 沿着石板路往回走，这段据说用了80余万块面包砖、每一寸都是历史的路走起来可比塑胶步道累人得多，走累了找家民谣酒馆坐下，于是有了这番以同一句话两种情境开始和结束的，哭笑不得的经历。 正品着酒保自称拿手的South Side和他聊着天听着歌，一个长相很高加索的妹子走近吧台点酒，顺势坐在了吧台另一端，接着是一眼尴尬的对视，出于礼貌，（现在让我回想来的话，和嘴欠），我拱出了一句「Привет」。然后蹩脚的俄语水平只让我听出了「Ты Русский」后便跟丢了节奏，只听见连珠炮一样的俄语倾泻而出（说实话，俄语的语义密度真的有些低），我完全愣住只能略显尴尬地「Я не знаю」。正准备拎包闪人的时候，应该是她的同行人走过来，又是一眼尴尬的对视，只不过这次换了先后顺序。「- Привет」「- Привет」（尴尬的微笑，both）。干了杯里的精酿，拎包走人，不然酒馆怕是要支付我挖地下室的工钱咯^.^。 #2哈市的地铁真的给我留下了最深刻的印象，四条线路对于这样一座城市明显是不够的。遥远的北国冰城，竟让我满眼看到香港早高峰的地铁站 省市博物馆和城市规划馆，总是到达一个省会城市必须要去的地方之一，更别提此行还要去龙博门前的苏军烈士纪念碑致敬。 不过黑龙江省博却和浙博、吉林省博完全不同。只能说原莫斯科商行这一建筑本身的历史和其意义可能都比龙博展出的内容更有价值，再加上酷暑天气没有空调的室内挤满了游客，烦躁心情自然在参观人群里扩散。 不过红博广场的公共交通确实足够便利，随便跳上了辆公交，便开始了这一天计划外的故事 看着133路线路图时发现正经过音乐厅，既然是联合国认定的音乐之城，那交响音乐会总是要听的吧，淘了张票，便确定了晚上的节目。正好街对面便是家购物中心，想来7层的建筑，消磨下不到两小时的时间还是绰绰有余的，更惊喜的，莫过于它居然有一大片共享书厅，无疑为下午的时光来了剂booster 而略显巧合的在于，几个月前还在思考的事情，就在这天豁然开朗。 这句话与前些天看到的一句「What we are waiting for is not as important as what happens to us while we are waiting. Trust the process.」有那么些异曲同工之妙。即便结果已经注定，拼搏的过程也不是完全没有意义，对吧？ 那么山猪吃细糠，ta到底能不能消化呢？ 只玩过几年键盘乐器的我，对交响乐的了解，仅限于知道几首考级时练过的经典曲目，比如经典的闭幕曲目《拉德斯基进行曲》。不得不说，现场听交响乐会带来的震撼，远超耳机音响。看指挥游刃有余地控场，利用强弱、节奏变化表现出乐章中的情感，与乐团一起，将经典篇章呈现出来，真的是一种不一样的体验。不过有时也会被小孩子的话语吸去了注意力，「又在盘他的圆号了」「鼓手好久没动了」，简直实体化弹幕哈哈 在同事的远程怂恿下，跑来了师大夜市觅食夜宵，哈市堵车问题确实比春城要好得多。几乎没费力气就直接到了夜市门口。怎么说呢，烟火气息很浓厚，物理上的烟火气息。坐在路边和一位满身纹身的小哥侃起来，疼吗，疼，说不疼也是假的，说着烤串大哥就加入进来，讲起自己理发学徒时跑去纹身，嫌疼纹一半放下了，讲来将去，成了听大哥诉苦，东北人骨子里对陌生人的信任真的是跑不掉的，和任何人都能敞开胸怀侃天侃地。 #3哈市规划馆是我见到的又一个用booklet做介绍的展馆 正如其所言，「留下历史印记，引领城市未来」，城市规划馆的意义正在于此。在规划馆里找寻一座城市的前世今生，效率要高过走街串巷几十倍不止。从平原湿地，到多元商埠，到工业化城市，哈市的构成元素在规划馆中一一陈列。每座城市规划馆必备的城市沙盘，则让人可以从另一个视角上，去观察这座城市的现状，甚至变迁。 哈市博物馆则带来了惊喜，展出的质量要比龙博高一个档次，涉猎方向广泛、展品虽不多，但胜在精致。而更重要的一点，同样位于古建筑里，它！有！空！调！（让我再吐槽龙博一次） 此行原本还要去东方卢浮宫——哈药六厂走一走，去龙塔俯瞰哈市夜景，但hey，不留些遗憾，还能叫人生嘛？还是那句话，时间会为每个人写出完美的结局，继续前行吧！ #结尾放些没写进来的东西吧","link":"/2023/zh-cn/Harbin"},{"title":"Python操作Excel表格","text":"工作需要整理一些信息，写的小脚本本文记录一下以后可能会用到的东西，随用随添加 #打开文件&amp;切换工作表* 此处用到的库为 xlwings 需要注意的只是文件路径和工作表名都为String格式 123import xlwings as xwwb = xw.Book(&quot;main.xlsx&quot;)sht = wb.sheets[&quot;sheet1&quot;] #添加图片到单元格翻一翻官方的文档很容易就能找到要用的函数。实际上如果有耐心翻文档或者在文档中搜一搜相关的关键词，我这篇文章就不用看了。 1add(image, link_to_file=False, save_with_document=True, left=None, top=None, width=None, height=None, name=None, update=False, scale=None, format=None, anchor=None, export_options=None) #获取单元格从上文中的函数信息可以很直观地看出向工作表插入图片时需要左端和顶端位置 首先说明一件事，在Excel工作表中，图片与单元格及其内部的文字不在同一层上，类似于Photoshop中位于两个图层。所以虽然说“插入图片”，其实应该叫做“把图片贴”在单元格的位置上 那么问题就只剩下找到单元格的位置了 12cell = sht.range(&quot;B1:F2&quot;)topPos, leftPos = cell.top, cell.left 一件比较重要的事情，如果目标单元格是个合并后的单元格，在sht.range()方法中要列出整个单元格的范围，而不是像Excel中写函数时只写出左上角单元格名称 -&gt; link #调整尺寸涉及到插入图片必然涉及到尺寸匹配 可以直接无视原图片比例直接暴力将图片拉到目标单元格的尺寸，也可以等比例放大/缩小图片使其能够进入单元格中。不管怎么做，图片和单元格的尺寸都需要先获取到 1cellW, cellH = cell.width, cell.height 图片的尺寸获取方法就太多了，这里不赘述 #插入文字与插入图片相比，文字插入可谓是相当简单了 1sht.range(f&quot;{cell_range}&quot;).value = f&quot;{your_text}&quot; 大功告成！ #收尾工作操作之后不要忘了保存及关闭Excel文件，或者只保存也可以，方便检查脚本运行结果是否符合要求 12wb.save()wb.close()","link":"/2022/zh-cn/officeExcelWithPython"},{"title":"小工具汇总","text":"最近工作上总是需要重复处理一些事情，比如整理文件(夹)，修改文件属性之类的，所以写了点小工具，随手记录一下，以便日后查找 按道理来说.bat脚本更方便使用，而且在windows端不需要安装任何东西，但无奈不擅长，哈哈 #获取当前路径下所有文件 包括子文件夹、(孙)文件夹,... 12345678910def all_files_path(root_dir): filepaths = [] for root,dirs,files in os.walk(root_dir): for file in files: file_path = os.path.join(root,file) filepaths.append(file_path) for dir in dirs: dir_path = os.path.join(root,dir) all_files_path(dir_path) return filepaths 以上函数的返回值是一个包含有root_dir路径下所有文件完整路径的一个列表 以此函数为基础，可以做很多很多事情了，比如删除所有的.un~文件，那么就直接对字符串结尾判断就可以了，然后利用os.unlink删除就好了。再结合正则表达式，功能也就更强大了。 #删除照片的EXIF信息照片的EXIF信息可能包含有很多敏感信息，例如拍摄地点，拍摄设备以及更进一步的拍摄参数等等。所以再上传图片或者发送图片给其他人的时候，最好还是先把EXIF信息清理一下 以下就用.jpg文件来做个示例 1234567from pyexiv2 import Imageimport jsonimg = Image(f&quot;{imgFileName}&quot;)exif = img.read_exif()with open(f&quot;{jsonFileName}&quot;, &apos;w&apos;) as f: json.dump(exif, f, indent=2) {&quot;Exif.Image.Make&quot;: &quot;Canon&quot;,&quot;Exif.Image.Model&quot;: &quot;Canon EOS 800D&quot;,&quot;Exif.Image.Orientation&quot;: &quot;1&quot;,&quot;Exif.Image.XResolution&quot;: &quot;72/1&quot;,&quot;Exif.Image.YResolution&quot;: &quot;72/1&quot;,&quot;Exif.Image.ResolutionUnit&quot;: &quot;2&quot;,&quot;Exif.Image.DateTime&quot;: &quot;2018:09:12 15:15:50&quot;,...} 也就是说，EXIF信息是以一种类似于字典的方式存储在图片文件中的，那么把所有的值改为空值或者随便什么没有意义的东西就可以了 1234567891011121314from pyexiv2 import Imagedef all_files_path(root_dir): # still remember this function, do you? ...if __name__ == &quot;__main__&quot;: all_files_path(os.getcwd()) for filepath in filepaths: if filepath.endswith(&quot;.JPG&quot;) or filepath.endswith(&quot;.jpg&quot;): img = Image(filepath) exif = img.read_exif() for i in exif: exif[i] = &quot;&quot; img.modify_exif(exif) 现在再读取图片的EXIF信息的话，结果会显示成这样： {&quot;Exif.Image.Make&quot;: &quot;&quot;,&quot;Exif.Image.Model&quot;: &quot;&quot;,&quot;Exif.Image.Orientation&quot;: &quot;&quot;,&quot;Exif.Image.XResolution&quot;: &quot;&quot;,&quot;Exif.Image.YResolution&quot;: &quot;&quot;,&quot;Exif.Image.ResolutionUnit&quot;: &quot;&quot;,&quot;Exif.Image.DateTime&quot;: &quot;&quot;,...} #结语接着整理接着添加嘿嘿","link":"/2022/zh-cn/miniTools"},{"title":"python-密码管理箱","text":"假期有点无聊，搞个密码管理器，做个记录Here: repository link #简介头脑一热做的一个小项目，要实现的功能大致如下： 登陆口令（称为口令，防止与后面的“密码”混淆）验证 添加密码条目 app/站点名称 账号/邮箱 密码 添加时间（程序自动生成） 密码加密 密码条目存储 密码条目查询 按app/站点名称 按账号/邮箱 更新/删除存储的密码条目 先获取密码条目在数据库中的ID作为参数——偷懒行为 显示对应密码条目后进行删除确认(2022.3) 修改登陆口令 (2022.1)新增密码生成，获取用户输入的密码长度数值，随机生成包括大小写字母、数字、符号的乱码作为强密码 交互的话先弄成命令行程序 已改用curses库实现 #各功能简介#登陆口令设置、验证及修改实现方法很简单了： 第一次启动程序要求设置一个登陆口令，重复输入检查无误后，hash加密，存储到数据库里。之后登陆对输入的密码进行校验即可。 设置登陆口令以及后续使用时输入口令需要对输入内容进行隐藏 用getpass库： 12import getpasspwd = getpass.getpass(&quot;[PASSWROD]: &quot;) # hide input 改用curses库后直接用curses.noecho()实现即可 #python curses库使用不开坑，不填坑，官方DOC放在这算了，都是很简单的操作 #密码加解密，密码条目增删、更新及查询由于hash加密的不可逆性，这里无法使用，因为后面还要查询密码并显示，所以需要寻找一种可逆的加密方法。偷个懒，直接平移ASCII码，偏移量选为当前时间的秒数+15，模拟一个随机加密。自然解密就是反向平移。 12345678910111213141516171819202122232425# offset functions。 only one is enough actually, with changing offset valuedef enascii(num: int, offset: int) -&gt; int: if num - offset &gt;= 33: return num - offset else: return 93 + num - offsetdef deascii(num: int, offset: int) -&gt; int: if num + offset &lt;= 126: return num + offset else: return num + offset - 93# encryptiondef encrypt(psw: str, offset: int) -&gt; str: encrypt_num = [] for i in psw: encrypt_num.append(enascii(ord(i), offset + 15)) encrypted = [chr(a) for a in encrypt_num] return &quot;&quot;.join(encrypted)# decryption, s as encrypted password stringdef decrypt(s: str, offset: int) -&gt; str: pwd = [chr(deascii(ord(a), offset + 15)) for a in s] return &quot;&quot;.join(pwd) 添加和更新密码时的密码输入没有隐藏，也算是偷个懒吧，毕竟有些比较复杂的密码输错了要重新输两遍甚至多遍难免会烦。 添加密码时，在输入站点和账户后对数据库中已有条目进行查询，若发现有同站点同账户密码条目询问是否停止添加转而更新密码。这里匹配方式为：站点信息完全相同，账户信息不区分大小。 sqlite3进行正则搜索遇到了点困难，翻了好久文档也没弄出个方法，最后选择基于StackOverflow中的一个方法完成。密码条目查询正则匹配设置大小写不敏感，即将上述解法中正则表达式定义改为： 1reg = re.compile(expr, re.I) 其余的内容就是数据库的操作了，放在这当备用吧 1234567891011121314import sqlite3db = sqlite3.connect(&quot;database.db&quot;)cur = db.cursor()cur.execute() # commands hereresult1 = cur.fetchall()result2 = cur.fetchone()db.commit()db.close()create_command = &quot;&quot;&quot;CREATE TABLE (table) ...&quot;&quot;&quot;add_command = &quot;&quot;&quot;INSERT INTO (table) (cols) VALUES (value)&quot;&quot;&quot; # value must be tuple typeselect_command = &quot;&quot;&quot;SELECT * FROM (table) WHERE ...&quot;&quot;&quot;update_command = &quot;&quot;&quot;UPDATE (table) SET ... WHERE ...&quot;&quot;&quot;delete_command = &quot;&quot;&quot;DELETE FROM (table) WHERE ...&quot;&quot;&quot; #To Do上面提到了一部分，随时想起什么再写上放这里，咕咕咕 GUI 改用curses库了 搜索功能使用正则匹配已完成 重复密码条目添加时进行提示与引导 又想起来一个，curses库只能在限定面板内显示查询结果，这样在对账号（邮箱）进行查询时，由于查询结果很多，可能由于终端面积不足而导致curses库运行出错 用curses pad解决了","link":"/2021/zh-cn/pswbox"},{"title":"Python Challenge记录帖1","text":"做个记录，http://www.pythonchallenge.com/源码repo #目录 Level 1 Level 2 Level 3 Level 4 Level 5 Level 6 Level 7 Level 8 Level 9 Level 10 Level 11 Level 12 Level 13 Level 14 Level 15 Level 16 Level 17 Level 18 Level 19 Level 20 #Level 0238=274877906944 替换地址为http://www.pythonchallenge.com/pc/def/274877906944.html，会自动跳转到正式关卡 #Level 1题目很明确，平移加密。对图片下方的紫色文字进行加密 12345678910line = &quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&apos;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;list1 = []for i in list(line): if i.isalpha(): j = ord(i)+2 s = chr(j) if j&lt;123 else chr(j-26) else: s = i list1.append(s)print(&quot;&quot;.join(list1)) 得到处理后的句子为 i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that&apos;s why this text is so long. using string.maketrans() is recommended. now apply on the url. OK，对网页链接map进行同样的操作，即可得到第二题的地址 另外注意到，很明显我的平移ascii的加密方式并不是它所提示的str.maketrans()，那么maketrans()实现了什么功能呢？原文放在这里好了，简单来说，就是生成一个转换方法，然后用str.translate()进行转换。传入不同数量的参数时会对应生成不同的转换方式，试试看 12345line = &quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&apos;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;label1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;label2 = &quot;cdefghijklmnopqrstuvwxyzab&quot;trans = str.maketrans(label1, label2)print(line.translate(trans)) i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that&apos;s why this text is so long. using string.maketrans() is recommended. now apply on the url. OK，相同的结果 #Level 2题目给的也很明显了，要查看网页源码，发现find rare charactors below的注释，那么就是这里了 为方便处理，将这一大段字符存入assets/txt_for_2.txt，开始统计字符出现的次数即可 123456from collections import Counterwith open(&quot;assets/txt_for_2.txt&quot;, &quot;r&quot;) as f: string = f.read()count = Counter(string)print(count) 得到结果 Counter({&apos;)&apos;: 6186, &apos;@&apos;: 6157, &apos;(&apos;: 6154, &apos;]&apos;: 6152, &apos;#&apos;: 6115, &apos;_&apos;: 6112, &apos;[&apos;: 6108, &apos;}&apos;: 6105, &apos;%&apos;: 6104, &apos;!&apos;: 6079, &apos;+&apos;: 6066, &apos;$&apos;: 6046, &apos;{&apos;: 6046, &apos;&amp;&apos;: 6043, &apos;*&apos;: 6034, &apos;^&apos;: 6030, &apos;\\n&apos;: 1219, &apos;e&apos;: 1, &apos;q&apos;: 1, &apos;u&apos;: 1, &apos;a&apos;: 1, &apos;l&apos;: 1, &apos;i&apos;: 1, &apos;t&apos;: 1, &apos;y&apos;: 1}) OK，只出现一次的字符组合起来即为下一题的地址，替换代入即可 #Level 3题目也很直白，正则匹配。源码是必须要看的咯，又发现一大篇字符。上手！ 1234567import rewith open(&quot;assets/txt_for_3.txt&quot;, &quot;r&quot;) as f: line = f.read()reg=re.compile(&apos;[a-z][A-Z]{3}[a-z][A-Z]{3}[a-z]&apos;)url = reg.findall(line)for u in url: print(u[4], end=&apos;&apos;) 得到结果linkedlist，替换地址。嘿嘿，瞧嘛，下一题的地址还有点区别了^.^ #Level 4页面上什么都没有了，图片有超链接，点击后进入页面显示the next nothing is 44827，抬头看一眼地址，voila！ 地址改为...?nothing=44827，嗯，又来了，the next nothing is 45439。看样子是要一个页面一个页面地跳转了。需要用到http请求类的模块了 123456789import requestsurl=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345&apos;r=requests.get(url)txt=r.textwhile True: url=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=&apos;+txt.split()[-1] r=requests.get(url) txt=r.text print(txt) 等待一个比较合理的输出结果就可以了 #Level 5pronouce it. 自然还是要看源码，图片地址为&quot;peakhell.jpg&quot;，下面还有一段页面上不显示的内容 123&lt;peakhell src=&quot;banner.p&quot;&gt;&lt;!-- peak hell sounds familiar ? --&gt;&lt;/peakhell&gt; 地址替换为banner.p试试。又得到一大篇不明所以的字符 回到开始，&quot;pronounce it&quot;，python有一个用于序列化和反序列化的模块名为pickle，应该就是了 1234567from urllib import requestimport pickleurl = &apos;http://www.pythonchallenge.com/pc/def/banner.p&apos;f = request.urlopen(url)result = pickle.load(f)print(result) 得到一个二维列表，粗略看一下，前三行的数字加在一起都为95，有可能代表字符出现的次数 1234for i in result: for j in i: print(j[0] * j[1], end = &apos;&apos;) print(&apos;\\n&apos;) 得到结果 #Level 6zip，压缩文件？拉链？ 地址替换为*.zip，哦，下载了文件名为channel.zip的压缩包。解压，发现readme.txt，嗯，和第四题有异曲同工之妙 123456789PATH = &apos;assets/channel/&apos;name = &apos;90052&apos;while True: filepath = PATH + name + &quot;.txt&quot; with open(filepath, &quot;r&quot;) as f: text = f.readline() print(text) s = text.split(&quot; &quot;) name = s[-1] 发现程序出错了，出错前最后一个文件内容为 collect the comments. zip comment是个嘛呢，google一下：A comment is optional text information that is embedded in a Zip file. -&gt;source用7zip打开压缩包，可以查看注释，发现压缩包里的文件均有一个字符长度的注释，有的是空格，有的是字母，那看样子是要用python对压缩包文件进行处理啦，用zipfile模块 12345678910111213import zipfilenum = &quot;90052&quot;comments = []f = zipfile.ZipFile(&quot;assets/channel.zip&quot;) # open zip filetry: while True: filepath = num + &quot;.txt&quot; line = f.read(filepath).decode(&quot;utf-8&quot;) # read txt file inside comment = f.getinfo(filepath).comment.decode(&quot;utf-8&quot;) # comment of txt file num = line.split(&quot; &quot;)[-1] comments.append(comment)except KeyError: print(&quot;&quot;.join(comments)) 用hockey替换地址，页面显示it&apos;s in the air. look at the letters.emm，无需多言 #Level 7emm，就一张图片，源码也没有信息了，那么信息还是在图片中，用opencv试试 注意到在图片中部有一横条是都为灰黑色，与图片整体极不和谐，从这里下手。用截图工具逐像素平移观察，发现大概7到9个像素后色块颜色发生改变，那就逐一试一下 123456789101112131415161718192021222324import cv2img = cv2.imread(&quot;assets/oxygen.png&quot;)offset1, offset2, offset3 = 7, 8, 9x, y, z, m = 0, 0, 0, int(img.shape[0] / 2 + 1)l1, l2, l3 = [], [], []while x &lt;= img.shape[1]: px1 = img[m, x] if px1[0] == px1[1] == px1[2]: l1.append(px1[0]) x += offset1while y &lt;= img.shape[1]: px2 = img[m, y] if px2[0] == px2[1] == px2[2]: l2.append(px2[0]) y += offset2while z &lt;= img.shape[1]: px3 = img[m, z] if px3[0] == px3[1] == px3[2]: l3.append(px3[0]) z += offset3print(f&quot;offset = 7: {l1}&quot;)print(f&quot;offset = 8: {l2}&quot;)print(f&quot;offset = 9: {l3}&quot;) 得到结果 offset = 7: [115, 109, 97, 114, 116, 32, 103, 117, 121, 44, 32, 121, 111, 117, 32, 109, 97, 100, 101, 32, 105, 116, 46, 32, 116, 104, 101, 32, 110, 101, 120, 116, 32, 108, 101, 118, 101, 108, 32, 105, 115, 32, 91, 49, 48, 53, 44, 32, 49, 49, 48, 44, 32, 49, 49, 54, 44, 32, 49, 48, 49, 44, 32, 49, 48, 51, 44, 32, 49, 49, 52, 44, 32, 49, 48, 53, 44, 32, 49, 49, 54, 44, 32, 49, 50, 49, 93]offset = 8: [115, 109, 97, 114, 116, 103, 117, 121, 44, 32, 121, 111, 32, 109, 97, 100, 101, 32, 105, 46, 32, 116, 104, 101, 32, 110, 120, 116, 32, 108, 101, 118, 101, 32, 105, 115, 32, 91, 49, 48, 44, 32, 49, 49, 48, 44, 32, 49, 54, 44, 32, 49, 48, 49, 32, 49, 48, 51, 44, 32, 49, 52, 44, 32, 49, 48, 53, 44, 49, 49, 54, 44, 32, 49, 50, 93]offset = 9: [115, 109, 97, 116, 32, 103, 121, 44, 32, 121, 117, 32, 109, 100, 101, 32, 105, 46, 32, 116, 101, 32, 110, 101, 116, 32, 108, 118, 101, 108, 32, 115, 32, 91, 48, 53, 44, 32, 49, 48, 44, 49, 49, 54, 44, 49, 48, 49, 32, 49, 48, 51, 32, 49, 49, 44, 32, 49, 48, 44, 32, 49, 54, 44, 32, 49, 49, 93] 尝试将这些数字视作ascii码转为字符 123456s1 = [chr(i) for i in l1]s2 = [chr(i) for i in l2]s3 = [chr(i) for i in l3]print(f&quot;offset = 7: {&apos;&apos;.join(s1)}&quot;)print(f&quot;offset = 8: {&apos;&apos;.join(s2)}&quot;)print(f&quot;offset = 9: {&apos;&apos;.join(s3)}&quot;) 得到结果 offset = 7: smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]offset = 8: smartguy, yo made i. the nxt leve is [10, 110, 16, 101 103, 14, 105,116, 12]offset = 9: smat gy, yu mde i. te net lvel s [05, 10,116,101 103 11, 10, 16, 11] 这样结果很明显了，offset=7得到的结果再进行一次ascii码转换即得到下一题地址 #level 8图片蜜蜂身体部分带有链接，点击发现需要登录。网页源码发现注释 12un: &apos;BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084&apos;pw: &apos;BZh91AY&amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13&lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08&apos; 自然对应的就是user name与password了，这串字符呢，是bzip2压缩过后的结果，那么解压就能得到原来的样子啦 123456import bz2l1 = b&apos;BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084&apos;l2 = b&apos;BZh91AY&amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13&lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08&apos;print(bz2.decompress(l1))print(bz2.decompress(l2)) 得到结果 b&apos;huge&apos;b&apos;file&apos; #Level 9网页标题叫connect the dots，源码中发现了一长串注释：first+second=?，以及各自后面的一串数字，那么应该是用这两串数字作为坐标咯 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npimg = cv2.imread(&quot;assets/good.jpg&quot;)first = [146,399,163,403,170,393,169,391,166,386,170,381,170,371,170,355,169,346,167,335,170,329,170,320,170,310,171,301,173,290,178,289,182,287,188,286,190,286,192,291,194,296,195,305,194,307,191,312,190,316,190,321,192,331,193,338,196,341,197,346,199,352,198,360,197,366,197,373,196,380,197,383,196,387,192,389,191,392,190,396,189,400,194,401,201,402,208,403,213,402,216,401,219,397,219,393,216,390,215,385,215,379,213,373,213,365,212,360,210,353,210,347,212,338,213,329,214,319,215,311,215,306,216,296,218,290,221,283,225,282,233,284,238,287,243,290,250,291,255,294,261,293,265,291,271,291,273,289,278,287,279,285,281,280,284,278,284,276,287,277,289,283,291,286,294,291,296,295,299,300,301,304,304,320,305,327,306,332,307,341,306,349,303,354,301,364,301,371,297,375,292,384,291,386,302,393,324,391,333,387,328,375,329,367,329,353,330,341,331,328,336,319,338,310,341,304,341,285,341,278,343,269,344,262,346,259,346,251,349,259,349,264,349,273,349,280,349,288,349,295,349,298,354,293,356,286,354,279,352,268,352,257,351,249,350,234,351,211,352,197,354,185,353,171,351,154,348,147,342,137,339,132,330,122,327,120,314,116,304,117,293,118,284,118,281,122,275,128,265,129,257,131,244,133,239,134,228,136,221,137,214,138,209,135,201,132,192,130,184,131,175,129,170,131,159,134,157,134,160,130,170,125,176,114,176,102,173,103,172,108,171,111,163,115,156,116,149,117,142,116,136,115,129,115,124,115,120,115,115,117,113,120,109,122,102,122,100,121,95,121,89,115,87,110,82,109,84,118,89,123,93,129,100,130,108,132,110,133,110,136,107,138,105,140,95,138,86,141,79,149,77,155,81,162,90,165,97,167,99,171,109,171,107,161,111,156,113,170,115,185,118,208,117,223,121,239,128,251,133,259,136,266,139,276,143,290,148,310,151,332,155,348,156,353,153,366,149,379,147,394,146,399]second = [156,141,165,135,169,131,176,130,187,134,191,140,191,146,186,150,179,155,175,157,168,157,163,157,159,157,158,164,159,175,159,181,157,191,154,197,153,205,153,210,152,212,147,215,146,218,143,220,132,220,125,217,119,209,116,196,115,185,114,172,114,167,112,161,109,165,107,170,99,171,97,167,89,164,81,162,77,155,81,148,87,140,96,138,105,141,110,136,111,126,113,129,118,117,128,114,137,115,146,114,155,115,158,121,157,128,156,134,157,136,156,136]pts1 = np.array(first, np.int32)pts1 = pts1.reshape((-1,2))pts2 = np.array(second, np.int32)pts2 = pts2.reshape((-1,2))cv2.polylines(img,[pts1, pts2],True,(0,255,255))cv2.imshow(&quot;img&quot;, img)cv2.waitKey(0) 事实证明，网页原图片是用不到的，直接生成一个纯色图片就可以 1img = np.zeros((512,512,3), np.uint8) 得到结果 那么是cow/bull/ox/cattle，尝试几次就知道了 #Level 10发现图片牛身体部分带有链接，点击发现一个未收尾的list，a = [1, 11, 21, 1211, 111221,。 没有系统刷过算法的我一时间没有看懂这是什么排列，搜索1, 11, 21, 1211, 111221后发现，原来这叫做Look-and-say sequence。好嘛知道这是什么东西了就好弄了，上手 123456789101112131415161718a = [&apos;1&apos;]c1, c2 = &apos;1&apos;, &apos;&apos;for _ in range(30): count, i, j = 0, 0, 0 while i &lt; len(c1): while j &lt; len(c1): if c1[i] == c1[j]: count += 1 j += 1 else: break c2 += str(count) + c1[i] i = j count = 0 a.append(c2) c1 = c2 c2 = &apos;&apos;print(len(a[30])) 得到下一题地址 #Level 11odd even，奇偶数，只有一张图片，那么自然还是要进行图片处理 对两坐标数值之和进行奇偶分类，分离图像 1234567891011121314import cv2import numpy as npimg = cv2.imread(&quot;assets/cave.jpg&quot;)x, y, _ = img.shapeimg1, img2 = np.zeros((x//2,y//2,3), np.uint8), np.zeros((x//2,y//2,3), np.uint8)for i in range(x): for j in range(y): if (i+j)%2 == 1: img1[i//2][j//2] = img[i][j] else: img2[i//2][j//2] = img[i][j]cv2.imshow(&quot;odd&quot;, img1)cv2.imshow(&quot;even&quot;, img2)cv2.waitKey(0) 得到&quot;even&quot;图像右上角的文字即为下一题地址 #Level 12dealing evil，有点摸不到头脑 图片源地址为evil1.jpg，会有evil2，evil3，甚至evil4，evil5吗，试试。 evil2.jpg显示not jpg, _.gfx .gfx是什么意思呢，google一下The GFX file type is primarily associated with Cue Club Image File. -&gt;source可以理解为是个图片类的扩展名，把evil2.jpg改为evil2.gfx果然是个文件链接。 再试试evil3.jpg，OK，显示no more evils了，那应该信息在evil2.gfx和evil1.jpg这两个文件当中了（还是需要继续尝试的，下一题需要） 打开evil2.gfx，尝试直接转为evil2.jpg 1234with open(&quot;assets/evil2.gfx&quot;, &quot;rb&quot;) as f: text = f.read()with open(&quot;assets/evil2.jpg&quot;, &quot;wb&quot;) as f: f.write(text) emm，打不开 众所周知dealing有发牌的意思，尝试如果把evil2.gfx中的信息逐字节分别注入到若干个文件中打开 从分为2个文件，一路尝试到分为5个文件，终于出现了能够读取的图像，连在一起即为下一题地址 12345with open(&quot;assets/evil2.gfx&quot;, &quot;rb&quot;) as f: text = f.read()for i in range(5): with open(f&apos;assets/{i}.jpg&apos;, &apos;wb&apos;) as f: f.write(text[i::5]) wait，那么evil1.jpg的作用是什么？找来找去看到图中发的牌都为5，大概是个线索吧，虽然被我忽略了... #Level 13按键5处有链接，得到一个xml文件。 说实话，这题我是从网上找的解析，触及我盲区了。这里补充一些自己的理解 xml-rpc就是一个post请求，形式为xml格式，执行结果也会以xml格式返回。python中执行这类操作有标准模块xmlrpc.client和xmlrpc.server，二者作用一目了然，这一题要用到的即为xmlrpc.client模块 123import xmlrpc.clientpost = xmlrpc.client.ServerProxy(&quot;http://www.pythonchallenge.com/pc/phonebook.php) 构建好ServerProxy对象后利用system.listMethods方法查询服务端提供的method 1print(post.system.listMethods()) 得到 [&apos;phone&apos;, &apos;system.listMethods&apos;, &apos;system.methodHelp&apos;, &apos;system.methodSignature&apos;, &apos;system.multicall&apos;, &apos;system.getCapabilities&apos;] 其中phone看起来是这个服务端特有的一个method方法，用system.methodHelp查询该method的作用 1print(post.system.methodHelp(&quot;phone&quot;)) Returns the phone of a person OK，需要的method也知道了，现在还缺少的条件就是person了。在网上查了一下才看见，原来上一题的evil4.jpg是有信息的，怪我太单纯，相信了它的鬼话。但是只有ie浏览器能够访问，或者利用curl语句获取，即为此题person的名字&quot;Bert&quot; 查询结果为 555-ITALY #Level 14结合walk around以及上方图片，应该与绕圈圈或者螺旋有关。下面的条形码(?)图片应该就是要处理的图片了。网页源码中带有注释 remember: 100*100 = (100+99+99+98) + (... 而且注意到wire.png在浏览器DevTools中的信息： Rendered size:100 × 100 pxRendered aspect ratio:1∶1Intrinsic size:10000 × 1 pxIntrinsic aspect ratio:10000∶1File size:15.9 kBCurrent source:http://www.pythonchallenge.com/pc/return/wire.png 它并不是100px*100px的图片，而是10000px*1px的图片 那么这个等式代表什么呢？ 举个简单的例子，一张5px*5px的图片，从最外侧沿直线一圈一圈螺旋状向内绕，如下图沿同颜色的色块走到边界然后转弯 那么以每次转弯为边界，每次走过的像素数依次是5,4,4,3,3,2,2,1,1 拓展到100px*100px的图片，那么上面的等式就能补全了 100*100 = 100+99+99+98+98+97+97+...+3+3+2+2+1+1=（100+99+99+98)+(98+97+97+96)+...+(5+4+4+3)+(3+2+2+1)+1 那么要对wire.png进行的处理即为螺旋式将10000个像素逐个填入到100px*100px的图像当中咯 1234567891011121314151617181920import cv2import numpy as npimg = cv2.imread(&quot;assets/wire.png&quot;)img1 = np.zeros((300, 300, 3), np.uint8)img1.fill(200)dirs = [(0,1), (1,0), (0,-1), (-1,0)]count, i, pos_x, pos_y = 200, 0, -1, 0dis = count//2while dis &gt; 0: for dir in dirs: dis = count//2 for _ in range(dis): pos_x = pos_x + dir[0] pos_y = pos_y + dir[1] img1[pos_x, pos_y] = img[0, i] i += 1 count -= 1cv2.imshow(&quot;result&quot;, img1)cv2.waitKey(0) voila~，诶他叫uzi，替换地址就是下一题了 #Level 15首先直接上结论，著名音乐家Mozart 为什么呢？注释里说 todo: buy flowers for tomorrow 然后我就去查了1月27日出生的名人，so，第一个就是WOLFGANG AMADEUS MOZART，然后就进入下一题了..... OK，回过头分析一下这道题，针对结果给出过程了属于是 首先1月27日肯定是个大日子没错了，注意图片右下角中的下月预览，共29天，那么这一年(1XX6年)是个闰年，而且当年1月1日为周四。再结合 he ain&apos;t the youngest, he is the second 也就是求从当今向前推，第二个最后一位数为6的闰年咯，虽然已经知道答案是1756了，但当然还是要做一下 1234567891011import calendarfront, count = 2020, 0while True: year = front + 6 if calendar.isleap(year) and calendar.weekday(year, 1, 1) == 3: count += 1 front -= 10 if count == 2: print(year) break #Level 16Let me get this straight 看上去应该是把这些粉/紫色的色块对齐？大概看了一下，前面四行像素中都只有一个粉/紫色块，那应该就是这样了。用截图工具逐像素查一下，发现这些粉/紫色块长度都为5个像素，那么接下来就容易了。 opencv无法处理.gif文件，所以花了点时间简单学习了下pillow的使用 首先要确定每行中粉/紫色块的位置(即其所在像素在整个像素行list中的索引值)，只需在一行像素中找到连续5个值完全相同的像素即可。 12345678910111213from PIL import Imageimg = Image.open(&quot;assets/mozart.gif&quot;)pixels = [img.getpixel((pos_x, 0)) for pos_x in range(img.size[0])]flag = 0for i in range(len(pixels)-5): for j in range(1, 5): if pixels[i] == pixels[i+j]: flag = 1 else: flag = 0 break if flag == 1: print(pixels[i]) 195 那么需要找的像素值就应该是195了。找到这个像素后将此像素之前的部分全部切下接到整行像素的末尾试一下 123456789from PIL import Imageimg = Image.open(&quot;assets/mozart.gif&quot;)for pos_y in range(img.size[1]): pixels = [img.getpixel((pos_x, pos_y)) for pos_x in range(img.size[0])] flag = pixels.index(195) pixels = pixels[flag:] + pixels[:flag] for pos_x in range(img.size[0]): img.putpixel((pos_x,pos_y), pixels[pos_x])img.show() 芝麻芝麻~ #Level 17诶，主图左下角的部分好像见过，是第四题的图，那么，又是一道网页请求类的题目？ 查看网页cookies you%20should%20have%20followed%20busynothing... 看样子应该是把第四题的首个地址改为...?busynothing=12345然后进行网页请求咯 然而并不是，除了一句that&apos;s it什么也没得到，猜测这可能是循环请求结束的节点。或许是要读取cookie内容？ 12345678910111213141516import reimport requestsurl=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=12345&apos;r=requests.get(url)txt=r.textcookies = r.cookies[&apos;info&apos;]while True: url=&apos;http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=&apos;+txt.split()[-1] r=requests.get(url) txt = r.text print(txt) cookies += r.cookies[&apos;info&apos;] result = re.search(&apos;the next busynothing is (\\d+)&apos;, txt) if result == None: breakprint(cookies) BZh91AY%26SY%94%3A%E2I%00%00%21%19%80P%81%11%00%AFg%9E%A0%20%00hE%3DM%B5%23%D0%D4%D1%E2%8D%06%A9%FA%26S%D4%D3%21%A1%EAi7h%9B%9A%2B%BF%60%22%C5WX%E1%ADL%80%E8V%3C%C6%A8%DBH%2632%18%A8x%01%08%21%8DS%0B%C8%AF%96KO%CA2%B0%F1%BD%1Du%A0%86%05%92s%B0%92%C4Bc%F1w%24S%85%09%09C%AE%24%90 emm，看开头像是之前做过的bzip2压缩，但是编码有问题。 12line = urllib.parse.unquote_to_bytes(cookies)print(line) 得到结果 b&apos;BZh91AY&amp;SY\\x94:\\xe2I\\x00\\x00!\\x19\\x80P\\x81\\x11\\x00\\xafg\\x9e\\xa0 \\x00hE=M\\xb5#\\xd0\\xd4\\xd1\\xe2\\x8d\\x06\\xa9\\xfa&amp;S\\xd4\\xd3!\\xa1\\xeai7h\\x9b\\x9a+\\xbf`&quot;\\xc5WX\\xe1\\xadL\\x80\\xe8V&lt;\\xc6\\xa8\\xdbH&amp;32\\x18\\xa8x\\x01\\x08!\\x8dS\\x0b\\xc8\\xaf\\x96KO\\xca2\\xb0\\xf1\\xbd\\x1du\\xa0\\x86\\x05\\x92s\\xb0\\x92\\xc4Bc\\xf1w$S\\x85\\t\\tC\\xae$\\x90&apos; 这回看上去和bzip压缩后的结果很像了，解压 1print(bz2.decompress(line).decode(&quot;utf-8&quot;)) is it the 26th already? call his father and inform him that &quot;the flowers are on their way&quot;. he&apos;ll understand. call his father，结合26th，那么应该是Mozart的父亲咯，在网上查了一下名叫Leopold，call自然是13题中的phone方法 1234import xmlrpc.clientpost = xmlrpc.client.ServerProxy(&quot;http://www.pythonchallenge.com/pc/phonebook.php&quot;)print(post.phone(&quot;Leopold&quot;)) 555-VIOLIN 替换.../violin.html试试 no! i mean yes! but ../stuff/violin.php. 继续修改网址。emm，网页题目叫it&apos;s me. What do you want?，内容是Leopold Mozart的画像。要做什么就很明了了 123456import requestsurl = &apos;http://www.pythonchallenge.com/pc/stuff/violin.php&apos;headers = {&apos;Cookie&apos;:&apos;info=the flowers are on their way&apos;}r = requests.get(url, headers=headers)print(r.text) 得到结果 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;it&apos;s me. what do you want?&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;br&gt;&lt;br&gt; &lt;center&gt;&lt;font color=&quot;gold&quot;&gt; &lt;img src=&quot;leopold.jpg&quot; border=&quot;0&quot;/&gt;&lt;br&gt;&lt;br&gt;oh well, don&apos;t you dare to forget the balloons.&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 替换为balloons即得到下一题地址了，哦对了，是在第17题题目的地址上替换，不是在Leopold画像的网页地址上替换 #Level 18Can you tell the difference? 两张图片，亮度略有差别。源码中带有注释 it is more obvious that what you might think 那既然这么说，就试试luminance/brightness咯。brightness.html页面没有区别，注释中内容变为了 maybe consider deltas.gz 替换地址，得到deltas.gz文件。处理.gz文件要用的应该就是gzip模块了 1234import gzipwith gzip.open(&apos;assets/deltas.gz&apos;, &apos;rb&apos;) as f: content = f.read().decode()print(content) 得到的结果很有意思，分为了两栏，但行数有所差别，或许要比较的是这两栏的区别？那么要用的就是difflib模块咯，去学习一下 1234567891011121314151617181920import gzip, difflibfile1, file2 = [], []with gzip.open(&apos;assets/deltas.gz&apos;, &apos;rb&apos;) as f: content = f.readline().decode() while content: file1.append(content[:53]+&apos;\\n&apos;) file2.append(content[56:]) content = f.readline().decode()diff = difflib.Differ().compare(file1, file2)l1, l2, common = [], [], []for line in diff: if line[0] == &apos;-&apos;: l1.append(line[2:-1]) elif line[0] == &apos;+&apos;: l2.append(line[2:-1]) else: common.append(line[2:-1])print(f&quot;l1: {l1}&quot;)print(f&quot;l2: {l2}&quot;)print(f&quot;common: {common}&quot;) 得到结果 l1: [&apos;89 50 4e 47 0d 0a 1a 0a ...]l2: [&apos;89 50 4e 47 0d 0a 1a 0a ...]common: [&apos;89 50 4e 47 0d 0a 1a 0a ...] 熟悉png文件结构的话已经看出比对出的三个结果应该怎么处理了。 三个结果起始的八个字节正是png文件的文件头(signature)-&gt;source 下面将三个结果分别存储为png文件，即得到下一题的地址、账号与密码。 123456789with open(&apos;assets/lvl18_1.png&apos;, &apos;wb&apos;) as f1: for line in l1: f1.write(bytes([int(o, 16) for o in line.split(&quot; &quot;) if o]))with open(&apos;assets/lvl18_2.png&apos;, &apos;wb&apos;) as f2: for line in l2: f2.write(bytes([int(o, 16) for o in line.split(&quot; &quot;) if o]))with open(&apos;assets/lvl18_3.png&apos;, &apos;wb&apos;) as f3: for line in common: f3.write(bytes([int(o, 16) for o in line.split(&quot; &quot;) if o])) #Level 19一张印度地图，以及网页注释中的一封邮件 看样子是要处理音频？而且说明了用base64进行编码，要用的自然就是base64.b64decode()了 123456import base64with open(&quot;assets/txt_for_19.txt&quot;, &quot;r&quot;) as f: content = f.read()audio = base64.b64decode(content)with open(&quot;assets/indian.wav&quot;, &apos;wb&apos;) as f: f.write(audio) 得到音频为 Sorry! 改地址试一下 &quot;what are you apologizing for?&quot; 看上去不对，有被忽略的线索。 对音频信息不是很了解，正好借刚刚的indian.wav这个文件学习一下wave模块和相关的参数含义 12345import wavewith wave.open(&apos;assets/indian.wav&apos;, &apos;rb&apos;) as sound: params = sound.getparams()print(params) _wave_params(nchannels=1, sampwidth=2, framerate=11025, nframes=55788, comptype=&apos;NONE&apos;, compname=&apos;not compressed&apos;) 大概是：单声道，采样率2byte，帧率11025hz，共55788帧，无压缩 注意到图片中陆地颜色和海洋颜色相反，reverse？尝试将音频整体翻转 12345678import wavewith wave.open(&apos;assets/indian.wav&apos;, &apos;rb&apos;) as sound: params = sound.getparams() content = sound.readframes(sound.getnframes())with wave.open(&apos;assets/results.wav&apos;, &apos;wb&apos;) as output: output.setparams(params=params) output.writeframes(content[::-1]) 得到的结果什么也听不出来，不对。尝试逐帧反转 12345678import wavewith wave.open(&apos;assets/indian.wav&apos;, &apos;rb&apos;) as sound: with wave.open(&apos;assets/results.wav&apos;, &apos;wb&apos;) as output: output.setparams(sound.getparams()) for i in range(sound.getnframes()): frame = sound.readframes(1) output.writeframes(frame[::-1]) &quot;you are an idiot~ ah, ah, ah, ah ... 虽然，但是，有被冒犯到... 替换网址，即得到进入下一题的链接 #Level 20属于是一点头绪都没有，此题参考了网上的解析，也通过此题学习了一下有关响应头中Content-Range以及请求头中Range的知识。这两项一般常见于断点续传和多线程下载 上图为本题主图unreal.jpg的响应头，表示当前文件的范围，修改请求头中的Range值即可访问其他范围的文件 现在已经知道0-30202区间为图片unreal.jpg，继续访问下一段。设置Range值为bytes=30203- 12345678910import requests, base64url = &apos;http://www.pythonchallenge.com/pc/hex/unreal.jpg&apos;cred = base64.b64encode(b&quot;butter:fly&quot;)requests.auth.HTTPBasicAuth(&quot;butter&quot;, &quot;fly&quot;)headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30203-&apos;}r = requests.get(url, headers=headers)print(r.headers)print(r.content.decode()) {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;34&apos;, &apos;Content-Range&apos;: &apos;bytes 30203-30236/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 10:22:00 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}Why don&apos;t you respect my privacy? 继续修改range值 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30237-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;47&apos;, &apos;Content-Range&apos;: &apos;bytes 30237-30283/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 10:55:42 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}we can go on in this way for really long time. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30284-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;11&apos;, &apos;Content-Range&apos;: &apos;bytes 30284-30294/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 11:07:43 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}stop this! 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30295-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;18&apos;, &apos;Content-Range&apos;: &apos;bytes 30295-30312/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:22:22 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}invader! invader! 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30313-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;34&apos;, &apos;Content-Range&apos;: &apos;bytes 30313-30346/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:23:12 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}ok, invader. you are inside now. 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=30347-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Type&apos;: &apos;text/html; charset=UTF-8&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:23:50 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;, &apos;Content-Length&apos;: &apos;0&apos;} 发现没有内容了，尝试访问2123456789字节外的内容 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=2123456879-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;45&apos;, &apos;Content-Range&apos;: &apos;bytes 2123456744-2123456788/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:25:37 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}esrever ni emankcin wen ruoy si drowssap eht 将得到的内容翻转，原句为 the password is your new nickname in reverse new nickname，应该是指前面的&quot;invader&quot;，也就是说密码应该是redavni 接下来向前读取 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=2123456743-&apos;} {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;32&apos;, &apos;Content-Range&apos;: &apos;bytes 2123456712-2123456743/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:26:54 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}and it is hiding at 1152983631. 好的，它给出了需要的信息的Range值 1headers = {&apos;Authorization&apos;: f&quot;Basic {cred.decode()}&quot;, &apos;Range&apos;:&apos;bytes=1152983631-&apos;} 得到了很长很长的结果，查看前20字节的信息 1print(r.content[:20]) {&apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;239733&apos;, &apos;Content-Range&apos;: &apos;bytes 1152983631-1153223363/2123456789&apos;, &apos;Content-Transfer-Encoding&apos;: &apos;binary&apos;, &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, &apos;Date&apos;: &apos;Mon, 18 Apr 2022 14:30:03 GMT&apos;, &apos;Server&apos;: &apos;lighttpd/1.4.55&apos;}b&apos;PK\\x03\\x04\\x14\\x00\\t\\x00\\x08\\x00;\\xa7\\xaa2\\xac\\xe5f\\x14\\xa9\\x00&apos; 起始的PK\\x03\\x04是zip文件的文件头-&gt;source 那么将这片内容保存为zip文件，解压密码为前面提到的redavni。就能打开了 12with open(&apos;assets/20.zip&apos;, &apos;wb&apos;) as f: f.write(r.content) 解压发现readme.txt，就是下一题的题目了。","link":"/2022/zh-cn/pythonchallenge"},{"title":"Python Challenge记录贴2","text":"同前一篇，做个记录源码repo #Contents Level 21 Level 22 Level 23 Level 24 Level 25 Level 26 Level 27 Level 28 Level 29 Level 30 Level 31 Level 32 Level 33 #Level 21 Yes! This is really level 21 in here.And yes, After you solve it, you&apos;ll be in level 22! Now for the level: We used to play this game when we were kids When I had no idea what to do, I looked backwards. 压缩包内有package.pack文件，先尝试16进制打开，看文件头会不会是常见的格式 123with open(&quot;assets/21/package.pack&quot;, &apos;rb&apos;) as f: data = f.read()print(data[:20].hex()) 789c000a40f5bf789c000740f8bf789c000640f9 78 9c“很像”是zlib文件的文件头 -&gt; source 那用zlib解压data变量试试 1234import zlib...data = zlib.decompress(data)... 789c000740f8bf789c000640f9bf789c00ff3f00 又是78 9c，或许需要解压很多次咯 123456789import zlibwith open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) else: breakprint(data[:20].hex()) 425a683931415926535991e82f2b0076a97fffff 文件头变了，42 5a。变成了bzip压缩文件的文件头 -&gt; source 1234567891011import zlib, bz2with open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) elif data[:2].hex() == &quot;425a&quot;: data = bz2.decompress(data) else: breakprint(data[:20].hex()) 808d96cbb572a70006587ada664f19ee846ba464 80 8d没搜到是哪种格式的文件头。对了，readme.txt中说过When I had no idea what to do, I looked backwards. 123456789101112131415import zlib, bz2with open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) elif data[:2].hex() == &quot;425a&quot;: data = bz2.decompress(data) elif data[-2:].hex() == &quot;9c78&quot;: data = zlib.decompress(data[::-1]) elif data[-2:].hex() == &quot;5a42&quot;: data = bz2.decompress(data[::-1]) else: breakprint(data[:20]) b&apos;sgol ruoy ta kool&apos; 得到的结果再倒过来念就是&quot;look at your logs&quot;。解压文件也会有日志产生吗？ 又是不懂的东西了。搜了一圈发现，原来这里说的日志是要我记录下每次解压所用的方法2333 12345678910111213141516171819202122import zlib, bz2from collections import Counterwith open(&apos;assets/21/package.pack&apos;, &apos;rb&apos;) as f: data = f.read()logs = []while True: if data[:2].hex() == &apos;789c&apos;: data = zlib.decompress(data) logs.append(&quot;*&quot;) elif data[:2].hex() == &quot;425a&quot;: data = bz2.decompress(data) logs.append(&quot;@&quot;) elif data[-2:].hex() == &quot;9c78&quot;: data = zlib.decompress(data[::-1]) logs.append(&quot;#&quot;) elif data[-2:].hex() == &quot;5a42&quot;: data = bz2.decompress(data[::-1]) logs.append(&quot;+&quot;) else: breakcount = Counter(logs)print(count) 直接将logs变量打印出来完全看不出内容。所以我用Counter统计一下每个字符出现的次数，也许有点用 Counter({&apos;*&apos;: 423, &apos;@&apos;: 300, &apos;#&apos;: 9}) 出现次数与其他两个差距这么大，可能#在这里是分隔符的作用 123lines = &quot;&quot;.join(logs).split(&quot;#&quot;)for line in lines: print(line) 得到结果 进入下一题 其实，在if条件语句中，利用bytes格式进行判断是个更好的选择，能节省下很多不必要的计算。但是16进制更方便查询文件头，所以程序中也就没进行修改. #Level 22注释中写到 &quot;or maybe white.gif would be mroe bright&quot;。修改地址为.../white.gif，获得了一张黑色的图片。什么意思呢 也不是纯黑哦，放大好多倍后发现在图片正中有个灰色（或者说“不那么黑”）的像素不停跳动 这回的图片含有很多帧了，不像16题中的mozart.gif，只有一帧。 首先看一下每帧的图像模式 123456from PIL import Image, ImageSequencepic = Image.open(&quot;assets/white.gif&quot;)frames = ImageSequence.Iterator(pic)for frame in frames: print(frame.mode) PRGBRGB 哦？第一帧与其他帧还不一样，是八位像素的模式 -&gt; source 不同的图像模式一定对应着不懂得像素值，这改怎么获取呢？pillow中有个ImageStat模块对图片进行一些数据上的计算，来试试看 1234567from PIL import Image, ImageSequence, ImageStatpic = Image.open(&quot;assets/white.gif&quot;)frames = ImageSequence.Iterator(pic)for frame in frames: stat = ImageStat.Stat(frame) print(stat.extrema) [(0, 8)][(0, 8), (0, 8), (0, 8)][(0, 8), (0, 8), (0, 8)][(0, 8), (0, 8), (0, 8)][(0, 8), (0, 8), (0, 8)]... OK，那我们要找的像素值一共有两种存在形式，8以及(8, 8, 8)。这回获取这些灰色像素的坐标就容易多了 123456789101112131415161718192021from PIL import Image, ImageSequencepic = Image.open(&quot;assets/white.gif&quot;)frames = ImageSequence.Iterator(pic)coords = []for frame in frames: for n_y in range(frame.size[1]): pixels = [frame.getpixel((n_x, n_y)) for n_x in range(frame.size[0])] try: pos_x = pixels.index(8) pos_y = n_y coords.append([pos_x, pos_y]) break except ValueError: try: pos_x = pixels.index((8, 8, 8)) pos_y = n_y coords.append([pos_x, pos_y]) except ValueError: passprint(coords) coords变量是个长度为133的二维列表，white.gif一共有133帧。应该已经获得了所有的坐标了。仔细看一下这些坐标，所有坐标值都在点(100, 100)周围两个像素内。哦对了，copper.html页面上的图片看上去应该是个方向操纵杆，或许这些坐标分别代表一个方向？ 1234567891011newpic = Image.new(&quot;1&quot;, (1000, 100))px = py = 0for coord in coords: x = coord[0] - 100 y = coord[1] - 100 if x == y == 0: x += 100 px += x py += y newpic.putpixel((px, py), 1)newpic.show() voila，下一题的地址~ #Level 23一头黄牛，页面标题叫做what is this module?。源码中有注释 TODO: do you owe someone an apology? now it is a good time totell him that you are sorry. Please show good manners althoughit has nothing to do with this level.----------it can&apos;t find it. this is an undocumented module.&apos;va gur snpr bs jung?&apos; 还记得19关Leopold Mozart的肖像下方的“Now you should apologize”吗？试试用同样的方法表达一下歉意吧 尝试了几种说辞后，我发现这次说的是真的，确实和本关没有关系 目光转向剩下的内容 &apos;va gur snpr bs jung&apos; 应该是最重要的信息了。哦，页面标题叫做“What is this module?”熟悉Python的人应该都知道“The Zen of Python”这首诗，运行import this即可将这首诗显示出来。这里用到的模块名字就叫“this”，是个巧合吗？ 打开python lib 文件夹下的 this.py，vscode里直接按住ctrl左键点击即可。诶，这首诗在源文件中并不是原样存储的 12345678910111213141516171819202122232425262728s = &quot;&quot;&quot;Gur Mra bs Clguba, ol Gvz CrgrefOrnhgvshy vf orggre guna htyl.Rkcyvpvg vf orggre guna vzcyvpvg.Fvzcyr vf orggre guna pbzcyrk.Pbzcyrk vf orggre guna pbzcyvpngrq.Syng vf orggre guna arfgrq.Fcnefr vf orggre guna qrafr.Ernqnovyvgl pbhagf.Fcrpvny pnfrf nera&apos;g fcrpvny rabhtu gb oernx gur ehyrf.Nygubhtu cenpgvpnyvgl orngf chevgl.Reebef fubhyq arire cnff fvyragyl.Hayrff rkcyvpvgyl fvyraprq.Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&apos;er Qhgpu.Abj vf orggre guna arire.Nygubhtu arire vf bsgra orggre guna *evtug* abj.Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg&apos;f n onq vqrn.Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg&apos;f qb zber bs gubfr!&quot;&quot;&quot;d = {}for c in (65, 97): for i in range(26): d[chr(i+c)] = chr((i+13) % 26 + c)print(&quot;&quot;.join([d.get(c, c) for c in s])) 需要先对所有字母进行ascii码平移才能解密这首诗。那，我们试试对&apos;va gur snpr bs jung&apos;进行相同的处理试试 123456s = &apos;va gur snpr bs jung&apos;d = {}for c in (65, 97): for i in range(26): d[chr(i+c)] = chr((i+13) % 26 + c)print(&quot;&quot;.join([d.get(c, c) for c in s])) in the face of what 谜面这么明显，到诗中找到那句话就可以了~ #Level 24页面标题叫 “From top to bottom”。图片名为maze.png。 要用路径搜寻算法？学习一下，正好利用这个机会试一下BFS算法和DFS算法，（或许也试一下A*算法）。MIT OpenCourseWare有针对这两种算法的质量很高的公开课 放大几倍后可以发现maze.png最外圈只有两个黑色像素点，一个在右上角，一个在左下角。这两个像素大概率就是整个迷宫的入口和出口了。迷宫的“墙”是白色，“路”是黑色，emmm，和往常的迷宫有点不同哈哈哈 虽然作了这么多关python challenge已经比较熟悉pillow模块了，这关我还是用OpenCV嘞 首先，入口和出口得到坐标是必需的 123456789101112import cv2import numpy as npimg = cv2.imread(&quot;assets/maze.png&quot;)width, height, _ = img.shapeblack = np.array([0, 0, 0])for i in range(width): if np.array_equal(img[0][i], black): print(i)for j in range(width): if np.array_equal(img[640][j], black): print(j) 6391 那么两个点的坐标就分别是(0, 639)和(640, 1)了。假设右上角是入口，左下角是出口。 #BFS 算法BFS算法中需要的FIFO队列可以通过Queue模块或collections模块中的deque类实现，最简单的python列表其实也可以满足要求 123456789101112131415161718192021222324252627282930313233343536373839404142434445import cv2import numpy as npdef inpic(coord): x = 0 &lt;= coord[0] &lt; 641 y = 0 &lt;= coord[1] &lt; 641 return x and ydef valid_check(coord, image, l): white = np.array([255, 255, 255]) return inpic(coord) and coord not in l and not np.array_equal(image[coord], white)def BFS(img: np.ndarray, entrance: np.ndarray, exit:np.ndarray): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue, visited = [exit], {} while queue: current = queue.pop(0) # get the head of the queue if current == entrance: break # early stop for dir in directions: pos = (current[0] + dir[0], current[1] + dir[1]) if valid_check(pos, img, visited): visited[pos] = current # link the surrounding pixels to central pixel queue.append(pos) path = [] while not np.array_equal(current, exit): path.append(current) current = visited[current] # reverse to find the path return pathif __name__ == &apos;__main__&apos;: img = cv2.imread(&quot;assets/maze.png&quot;) # width, height, _ = img.shape # black = np.array([0, 0, 0]) # for i in range(width): # if np.array_equal(img[0][i], black): # print(i) # 639 # for j in range(width): # if np.array_equal(img[640][j], black): # print(j) # 1 entrance, exit = (0, 639), (640, 1) path = BFS(img=img, entrance=entrance, exit=exit) path.append(exit) print(f&quot;First 20 coordinates:\\n{path[:20]}&quot;) print(f&quot;Last 20 coordinates:\\n{path[-20:]}&quot;) First 20 coordinates:[(0, 639), (1, 639), (2, 639), (3, 639), (4, 639), (5, 639), (6, 639), (7, 639), (8, 639), (9, 639), (10, 639), (11, 639), (11, 638), (11, 637), (11, 636), (11, 635), (12, 635), (13, 635), (14, 635), (15, 635)]Last 20 coordinates:[(637, 9), (636, 9), (635, 9), (635, 8), (635, 7), (635, 6), (635, 5), (635, 4), (635, 3), (634, 3), (633, 3), (633, 2), (633, 1), (634, 1), (635, 1), (636, 1), (637, 1), (638, 1), (639, 1), (640, 1)] 结合maze.png原图，头尾的坐标点看上去是个合理的路径了。当然也可以输出更多的坐标点来验证。 #DFS算法1234567891011121314151617181920def DFS_sub(img: np.ndarray, current, entrance: np.array, queue: list, visited: dict): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for dir in directions: pos = (current[0] + dir[0], current[1] + dir[1]) if valid_check(pos, img, visited): visited[pos] = current queue.append(pos) return queue, visiteddef DFS(img, entrance, exit): queue, visited, path = [exit], {}, [] while queue: current = queue.pop() if current == entrance: break queue, visited = DFS_sub(img, current, entrance, queue, visited) while not np.array_equal(current, exit): path.append(current) current = visited[current] return path #那么，接下来呢？说实话，接下来做什么我完全没头绪了。上网搜了一下，发现本题最重要的信息不是这些坐标，而是这些坐标点上像素的RGB值，准确来说是R值，因为所有点的B和G值都为0。每两个点中取一个非零值（都为零的话取零），然后就得到结果了。不过我没查到有关8075是zip文件的文件头的信息。 把上面最后一段代码改为如下 123456path = DFS(img=img, entrance=entrance, exit=exit)[1:] # change the function name to use different methodstofile = []for c in path: tofile.append(img[c][2])with open(&quot;assets/maze.zip&quot;, &apos;wb&apos;) as f: f.write(bytes(tofile[::2])) 得到的maze.zip文件中就有下一题的地址了，还有另一个压缩文件mybroken.zip目前还没用上。 #Level 25 网页标题：Imagin how they sound源码中的注释：Can you see the waves? 主图地址为lake1.jpg。它既然说“sound”，那改成音频文件扩展名试试，lake1.wav、lake1.mp3之类的。尝试几下就会发现lake1.wav是可以下载的文件，从文件名中也能看出来还会有一大堆音频文件，lake2、lake3…… 1234567891011import requestsi = 1while True: url = f&quot;http://www.pythonchallenge.com/pc/hex/lake{i}.wav&quot; r = requests.get(url, auth=requests.auth.HTTPBasicAuth(&apos;butter&apos;, &apos;fly&apos;)) if r.status_code != 200: break # break when url is invalid with open(f&quot;assets/25/lake{i}.wav&quot;, &apos;wb&apos;) as f: f.write(r.content) i += 1 一共获得了25个音频文件，主图lake1.jpg恰好是25个小块组成的拼图，那么要做的应该就是把这些音频文件转成图片然后拼在一起咯 那么，应该用音频中的什么信息生成图片呢？尝试了波形、频谱，输出都不像。没办法，又得搜一下了。 原来是要把每个音频文件直接通过bytes格式保存成音频文件…… 好吧，给我再久我也想不到这个办法 1234import wavewaves = [wave.open(f&quot;assets/25/lake{i}.wav&quot;, &apos;rb&apos;) for i in range(1, 26)]for audio in waves: print(audio.getparams()) 每个音频文件参数都相同 _wave_params(nchannels=1, sampwidth=1, framerate=9600, nframes=10800, comptype=&apos;NONE&apos;, compname=&apos;not compressed&apos;) 从这些参数中能看出来，每个音频文件大概都包含10800个字节，一张3600个像素的图片恰好也包含10800个字节。 12345678910from PIL import Imagej = 0img = Image.new(&apos;RGB&apos;, (300, 300), 0)waves = [wave.open(f&quot;assets/25/lake{i}.wav&quot;, &apos;rb&apos;) for i in range(1, 26)]for audio in waves: tmp = Image.frombytes(&quot;RGB&quot;, (60, 60), bytes(audio.readframes(10800))) img.paste(tmp, [j%5*60, j//5*60]) j += 1img.show() 结果就在输出的图片中了 #Level 26Be a man - Apologize! 源码中的注释只有一句：you&apos;ve got his email. Email，26道题以来见到的唯一一个邮箱在19关。所以并不是用修改请求头的方式道歉，而是应该写邮件道歉咯2333。然而，可能因为站点运行这么多年有些程序已经不运行了？我发了邮件但一直没接到回复……上网搜索这题的时候发现是应该接到一封回复的。会给一个md5加密后的值，用来处理[24关]的mybroken.zip Never mind that.Have you found my broken zip?md5: bbb8b499a0eef99b52c7f13f4e78c24bCan you believe what one mistake can lead to? 步骤很明显了，不断修改mybroken.zip文件，得到一个相同地md5加密结果 事实上，我用7-zip解压了mybroken.zip后里面的mybroken.gif就是完整的，虽然解压的时候提示了CRC failed。图中是单词“Speed”。我也不知道7-zip是怎么做到的，但是网上的一些解法中是提到这个图片是不完整的，需要修改mybroken.zip后才能完成显示出来。 它说了“one mistake”，那么应该是只有一个字节出现错误了呗。那就逐字节修改，然后看一下md5加密结果就行了 1234567891011121314151617import hashlibstandard = &quot;bbb8b499a0eef99b52c7f13f4e78c24b&quot;with open(&quot;assets/maze/mybroken.zip&quot;, &quot;rb&quot;) as f: original = f.read()flag = 0for i in range(len(original)): for j in range(256): data = original[:i] + bytes([j]) + original[i+1:] if hashlib.md5(data).hexdigest() == standard: flag = 1 break if flag: breakprint(flag)with open(&quot;assets/maze/new.zip&quot;, &apos;wb&apos;) as new_file: new_file.write(data) 这回解压mybroken.zip就不会报CRC failed了。再结合页面上说的“I&apos;m missing the boat”，答案就是speedboat了。 #Level 27Between the tables. 图片带有链接，需要另一组用户名和密码才能访问。源码注释中： did you say gif?oh, and this is NOT a repeat of 14 主图地址zigzag.jpg，改成zigzag.gif，是一张灰度图。 回过头看看，自从23关以来我还没完全独立完成一道题过。题目是越来越难了，这题当然也不例外。 gif文件通常都是以P模式保存的，这样可以节约很多空间。P模式需要一个调色板(Palette)来显示图片。每个像素中所存储的信息为对应颜色在调色板中的位置。此题的关键就是图片zigzag.gif的调色板了 12345from PIL import Imageimg = Image.open(&apos;assets/zigzag.gif&apos;)palette = img.getpalette()print(palette) 这个调色板中数值排列十分规律，每三个数值都完全一致。每组取一个值即可 下一步就是将像素中存储的信息转化为对应的颜色了 1234567891011from PIL import Imageimg = Image.open(&apos;assets/zigzag.gif&apos;)palette = img.getpalette()[::3]trans = bytes.maketrans(bytes([i for i in range(256)]), bytes(palette))img_b = img.tobytes()print(f&apos;img_b first 20: {img_b[:20].hex()}&apos;)print(f&apos;img_b last 20: {img_b[-20:].hex()}&apos;)result = bytes.translate(img_b, trans)print(f&apos;result first 20: {result[:20].hex()}&apos;)print(f&apos;result last 20: {result[-20:].hex()}&apos;) img_b first 20: d7d0cb0cfe3c8b4842bd7fb0ad46aacf27207e8eimg_b last 20: 7a5f0d5b95e3b20e6a0388bf05d439b8174efa64result first 20: d0cb0cfe3c8b4842bd7fb0ad46aacf27207e8ea4result last 20: 5f0d5b95e3b20e6a0388bf05d439b8174efa645d 看上去img_b和result两个变量中的信息有很多的重叠，除了首尾两个字节。 12print(len(img_b) == len(result))print(img_b[1:] == result[:-1]) TrueFalse 好吧，虽然两个变量长度完全相同，但内容还是有很多不同的地方的。那，对比一下吧 123456789raw, img_b = raw[1:], img_b[:-1]diff_raw = []diff_b = []for i in range(len(raw)): if raw[i] != img_b[i]: diff_raw.append(raw[i]) diff_b.append(img_b[i])print(bytes(diff_raw)[:20])print(bytes(diff_b)[:20]) b&apos;BZh91AY&amp;SY\\xe0\\xaaYF\\x00\\x17\\x9a\\x11\\x80@&apos;b&apos;\\x99\\xbdQ\\x82\\xf2\\x89S\\x04\\x15E\\x047 \\x04\\x95\\xe4N\\x9b\\xd5\\xa8&apos; 第一个很明显是bzip压缩的内容了，另一个则毫无头绪 123clue1, clue2 = bytes(diff_raw), bytes(diff_b)clue1 = bz2.BZ2Decompressor().decompress(clue1)print(clue1) 获得了一大篇内容，其中一个是网址，其他的都是单词。利用python set去下重 12l1 = clue1.decode().split(&apos; &apos;)print(set(l1)) {&apos;else&apos;, &apos;is&apos;, &apos;raise&apos;, &apos;pass&apos;, &apos;assert&apos;, &apos;while&apos;, &quot;while&apos;&quot;, &apos;yield&apos;, &apos;in&apos;, &apos;lambda&apos;, &apos;for&apos;, &apos;return&apos;, &apos;or&apos;, &apos;../ring/bell.html&apos;, &apos;exec&apos;, &apos;def&apos;, &apos;if&apos;, &apos;break&apos;, &apos;continue&apos;, &apos;not&apos;, &apos;and&apos;, &apos;import&apos;, &quot;b&apos;../ring/bell.html&quot;, &apos;switch&apos;, &apos;class&apos;, &apos;except&apos;, &apos;global&apos;, &apos;del&apos;, &apos;repeat&apos;, &apos;from&apos;, &apos;elif&apos;, &apos;try&apos;, &apos;print&apos;, &apos;finally&apos;} ../ring/bell.html就是主图超链接的网址，那么用户名和密码就应该在剩下的这些单词中了。问题是，到底是哪两个呢 把这些不同信息的位置记录下来，在对应位置进行标记，可以获得最重要的信息 12345678910...for i in range(len(raw)): if raw[i] != img_b[i]: diff_raw.append(raw[i]) diff_b.append(img_b[i]) pos.append(i)newimg = Image.new(&quot;1&quot;, img.size, 1)for v in pos: newimg.putpixel((v%width, v//width), 0)newimg.show() 好了，那么接下来把python关键词去除掉就可以了 123456clue1, clue2 = bytes(diff_raw), bytes(diff_b)clue1 = bz2.BZ2Decompressor().decompress(clue1)words = set(clue1.decode().split(&apos; &apos;))for ele in words: if not keyword.iskeyword(ele): print(ele) repeatexec../ring/bell.htmlswitchprint 这道题需要修改一下了，python3删除了一部分关键词，原本应该只剩下两个单词的。接下来要做的也不难，找到在python2和python3中都不是关键词的两个单词就可以了。 可能要用到的信息：python2的关键词 #Level 28Ring-Ring-Ring, say it out loud. 读起来有些像grin或者green。先试试grin.html you are not happy - you are feeling sick. 好的，那么一定是green.html了 Yes, Green! 啊？就这一句，就没了？ 回过头来仔细看一下主图bell.png，可以看到整张图上面有很多颜色略不同的条带。那信息应该藏在RGB的G值中咯 123456789import cv2import numpy as npimg = cv2.imread(&quot;assets/bell.png&quot;)height, width, _ = img.shapeb, g, r = cv2.split(img)g1 = np.reshape(g, (1, -1))[0]np.set_printoptions(threshold=np.inf)print(g1) g1存储有307200个数值，仔细看一下，相邻两个数值的差值好像都是42/-42 对相邻的数值做减法，把42/-42都踢掉试一下 12345678910111213import cv2import numpy as npimg = cv2.imread(&quot;assets/bell.png&quot;)height, width, _ = img.shapeb, g, r = cv2.split(img)g1 = np.reshape(g, (1, -1))[0].astype(np.int8)g2= g1[0::2] - g1[1::2]l = []for i in g2: if i != 42 and i != -42: l.append(i)print(l) [119, -104, -111, 100, 117, 110, -110, 105, 116, -40, 41, -46, -115, 112, -108, 105, 116, 40, 41, 91, 48, -93, 32, -63] 有没有让你想起类似ascii码之类的？反正我有。 1print(&quot;&quot;.join(chr(abs(j)) for j in l)) whodunnit().split()[0] ? 做了什么？我最初以为是指站点，在About页面里可以看到，Nadav Samet创立的这个站点。试了一下，名和姓都不是答案。 诶，就差一步就独立解出这题了，这里指的是Python的创立者。555 #Level 29这关很有趣。网页和源码中都没什么太有价值的东西。 如果你不看源码行数的话…… 多数时间我都用dev tools查看源码。没有源码行数显示，没发现什么信息 不过，这么二十多关下来，我也习惯了用requests模块获取源码看一下了。这成了我完成这关的重要一步，哈哈哈 12345import requestsurl = &quot;http://www.pythonchallenge.com/pc/ring/guido.html&quot;r = requests.get(url, auth=(&quot;repeat&quot;, &quot;switch&quot;))print(r.text) 除了网页的内容之外，在源码后面有一大堆空行。终端中显示出来是看不出区别了 在guido.html页面里按ctrl+u。不同的浏览器快捷键可能有所不同。在microsoft edge dev中这个快捷键转入了view-source:http://www.pythonchallenge.com/pc/ring/guido.html页面，在这个页面里看源码清晰很多。 全选一下，就会发现，源码后面的空行长度各不相同。好了，这应该就是解题之关键了。 123456import requestsurl = &quot;http://www.pythonchallenge.com/pc/ring/guido.html&quot;r = requests.get(url, auth=(&quot;repeat&quot;, &quot;switch&quot;))msg = [len(i) for i in r.text.split(&quot;\\n&quot;)[12:]]print(msg) [66, 90, 104, 57, 49, 65, 89, 38, 83, 89, 217, 194, 112, 24, 0, 0, 4, 157, 128, 96, 128, 0, 0, 128, 32, 46, 47, 156, 32, 32, 0, 49, 76, 152, 153, 6, 70, 17, 50, 104, 100, 6, 106, 85, 100, 185, 158, 198, 24, 197, 146, 82, 72, 229, 90, 34, 1, 186, 167, 128, 127, 139, 185, 34, 156, 40, 72, 108, 225, 56, 12, 0, 0] ascii码？ 1msg = [chr(len(i)) for i in r.text.split(&quot;\\n&quot;)[12:]] [&apos;B&apos;, &apos;Z&apos;, &apos;h&apos;, &apos;9&apos;, &apos;1&apos;, &apos;A&apos;, &apos;Y&apos;, &apos;&amp;&apos;, &apos;S&apos;, &apos;Y&apos;, &apos;Ù&apos;, &apos;Â&apos;, &apos;p&apos;, &apos;\\x18&apos;, &apos;\\x00&apos;, &apos;\\x00&apos;, &apos;\\x04&apos;, &apos;\\x9d&apos;, &apos;\\x80&apos;, &apos;`&apos;, &apos;\\x80&apos;, &apos;\\x00&apos;, &apos;\\x00&apos;, &apos;\\x80&apos;, &apos; &apos;, &apos;.&apos;, &apos;/&apos;, &apos;\\x9c&apos;, &apos; &apos;, &apos; &apos;, &apos;\\x00&apos;, &apos;1&apos;, &apos;L&apos;, &apos;\\x98&apos;, &apos;\\x99&apos;, &apos;\\x06&apos;, &apos;F&apos;, &apos;\\x11&apos;, &apos;2&apos;, &apos;h&apos;, &apos;d&apos;, &apos;\\x06&apos;, &apos;j&apos;, &apos;U&apos;, &apos;d&apos;, &apos;¹&apos;, &apos;\\x9e&apos;, &apos;Æ&apos;, &apos;\\x18&apos;, &apos;Å&apos;, &apos;\\x92&apos;, &apos;R&apos;, &apos;H&apos;, &apos;å&apos;, &apos;Z&apos;, &apos;&quot;&apos;, &apos;\\x01&apos;, &apos;º&apos;, &apos;§&apos;, &apos;\\x80&apos;, &apos;\\x7f&apos;, &apos;\\x8b&apos;, &apos;¹&apos;, &apos;&quot;&apos;, &apos;\\x9c&apos;, &apos;(&apos;, &apos;H&apos;, &apos;l&apos;, &apos;á&apos;, &apos;8&apos;, &apos;\\x0c&apos;, &apos;\\x00&apos;, &apos;\\x00&apos;] 从前几个字符也能看出来是bzip压缩过的内容了 123456import requests, bz2url = &quot;http://www.pythonchallenge.com/pc/ring/guido.html&quot;r = requests.get(url, auth=(&quot;repeat&quot;, &quot;switch&quot;))msg = [len(i) for i in r.text.split(&quot;\\n&quot;)[12:]]print(bz2.decompress(bytes(msg))) b&quot;Isn&apos;t it clear? I am yankeedoodle!&quot; 哈哈，这道题有些运气成分在里面了，没遇到什么太大的困难。 #Level 30从源码中可以看出来要访问yankeedoodle.cvs文件 下载下来粗略看一眼，都是0到1之间的“随机”数 123456import numpy as npwith open(&quot;assets/yankeedoodle.csv&quot;, &quot;r&quot;) as f: data = [float(x.strip()) for x in f.read().split(&quot;,&quot;)]content = np.array([data])n = len(img[0])print(n) 7367 尝试把这些数字当成一张图片来处理，首先需要知道图片该有多大，分解7367 123456789import mathdef resolve(n): factors = [] for i in range(2, int(math.sqrt(n))): if n % i == 0: factors.append([i, int(n/i)]) return factorsprint(resolve(n)) [[53, 139]] 图片大小只有一种可能了，53px*139px 12345import cv2height, width = resolve(n)[0]content.resize((height, width))cv2.imshow(&quot;img&quot;, content)cv2.waitKey() 输出糊成一片。交换高和宽的数值 1img.resize((width, height)) 这下能看出图片内容了：n=str(x[i])[5]+str(x[i+1])[5]+str(x[i+2])[6]。没猜错的话，要做的就是把这些浮点数对应位置的数字提取出来咯 123456789with open(&quot;assets/yankeedoodle.csv&quot;, &quot;r&quot;) as f: data = [x.strip() for x in f.read().split(&quot;,&quot;)]content = np.array([data])n = len(content[0])info = []for i in range(0, n-2, 3): n = str(content[0][i])[5] + str(content[0][i+1])[5] + str(content[0][i+2])[6] info.append(n)print(info) 得到了一大篇数字，又是ascii码？ 12345info = []for i in range(0, n-2, 3): n = chr(int(str(content[0][i])[5] + str(content[0][i+1])[5] + str(content[0][i+2])[6])) info.append(n)print(&quot;&quot;.join(info)) So, you found the hidden message.There is lots of room here for a long message, but we only need very little space to say &quot;look at grandpa&quot;, so the rest is just garbage.(还有一大堆乱码) 好了，那就是Grandpa了。 #Level 31Where am I? 主图grandpa.jpg带有链接，可能是下一题的页面？需要另一组用户名和密码验证，进不去。源码中的注释为 short break, this ***REALLY*** has nothing to do with Python 那既然都这么说了，百度/谷歌/bing/yandex识图吧。搜索结果叫 Ko Samui (也称 Koh Samui)，是泰国第二大岛屿。 尝试ko/samui、koh/samui、kosamui/thailand、kohsamui/thailand。好家伙试了四遍才试出来…… 新页面上来就一句话“That was too easy. You are still on 31...” 好吧，那这页才是真正的第31关咯 页面标题：UFOs? 源码里什么信息都没有。哦不对，图片名字是个信息，&quot;mandelbrot&quot;。 好了，又是道完全没头绪的题目了，再去搜索一下吧 123456789101112def mandelbrot(size: tuple): left, top, width, height = 0.34, 0.57, 0.036, 0.027 iteration = 128 xstep, ystep = width/size[0], height/size[1] for y in range(size[1]-1, -1, -1): for x in range(size[0]): c, z = complex(left+x*xstep, top+y*ystep), complex(0, 0) for count in range(iteration): z = z**2 + c if abs(z) &gt; 2: break yield count 这是本道题中生成mandelbrot set的方法，别问我各个参数的意义，hhh 12345img = Image.open(&quot;assets/mandelbrot.gif&quot;)print(img.size)newimg = img.copy()newimg.putdata(list(mandelbrot(img.size)))newimg.show() 获取到的图片和原图mandelbrot.gif非常相像 12diff = [(a - b) for a, b in zip(img.getdata(), newimg.getdata()) if a != b]print(diff) 变量diff中的数值都为16/-16，一共1679个数据 将其改为1-bit图像，对1679进行因数分解就能知道图片大小只能为23px*73px。 123result = Image.new(&quot;1&quot;, (23, 73))result.putdata([(i &gt; 0) and 1 or 0 for i in diff])result.show() 这样获得的图像就是于1974年送入太空的大名鼎鼎的Arecibo message 那么答案自然就是arecibo了 #Level 32页面标题etch-a-scetch。看上去是要我们在页面上画点什么 源码中提到了warmup.txt，顾名思义，这只是开胃菜咯 比较简单，直接用arecibo.html就能徒手点出来哈哈哈 You want to go up? Let&apos;s scale this up then. Now get serious and solve this. 好了，这下子没法徒手完成了 必须要承认的是，我把这题想的太简单了，先停在这里吧，有些急事要做…… 说起来很有意思，同事前两天正好在玩同样的一个游戏，所以我向他请教了一下这类游戏的解法。结果同事说他也刚开始玩，和我一样，硬解。不过他也告诉我说这游戏名字叫Nonogram，网上有很多在线的解答网站。 好了，对up.txt进行一些小修改，再结合在线解答网站的**亿点点**帮助，很快就得到了一条小蛇。 snake.html 404。答案是python.html……吗 123Congrats! You made it through to the smiling python.&quot;Free&quot; as in &quot;Free speech&quot;, not as in &quot;free... 嗯，搜一下就知道了 #Level 33终于到最后一关了。尽管上一关还没真正动手。我过完这一关就回头做一下，真的^o^。 图片名叫beer1.jpg，做了这么多关了，自然要试一下beer2.jpg。显示&quot;no, png&quot;。 好，那就是beer2.png了。 网页源码中的注释自然也不能忘记 123456&lt;!--If you are blinded by the light,remove its power, with its might.Then from the ashes, fair and square,another truth at you will glare.--&gt; 简单猜测着翻译一下： 去掉比较亮的像素点，调整为正方形图像 首先，确认一下beer2.png的图像模式 123from PIL import Imageimg = Image.open(&quot;assets/beer2.png&quot;)print(img.mode) L 从Pillow文档中可以查到&quot;L&quot;表示八位黑白图像 去除比较亮的像素点，当图片恰好能调整成为正方形时输出图像 123456789101112131415from PIL import Imagefrom math import sqrtimg = Image.open(&quot;assets/beer2.png&quot;)values = list(img.getdata())while True: max_value = max(values) values = [i for i in values if i != max_value] if len(values) == 0: break root = sqrt(len(values)) if root == int(root): output = Image.new(&quot;L&quot;, (int(root), int(root))) output.putdata(values) output.save(f&quot;assets/33/{int(root)}.png&quot;) 110.png之后的图像中出现了不一样的字母，不过不太清楚 1234567891011121314151617from PIL import Imagefrom math import sqrtimg = Image.open(&quot;assets/beer2.png&quot;)values = list(img.getdata())while True: max_value = max(values) values = [i for i in values if i != max_value] if len(values) == 0: break root = sqrt(len(values)) if root == int(root): output = Image.new(&quot;L&quot;, (int(root), int(root))) max_value = max(values) l = [255 if j == max_value else 0 for j in values] output.putdata(l) output.save(f&quot;assets/33/{int(root)}.png&quot;) 那么，带着框的字母应该能够组成本关的答案咯，修改地址为snilmerg.html，没用。 啊！字母的排列顺序应该与其出现顺序一致，换句话说，103.png比98.png先出现，那么字母g就应该在字母r之前，所以答案应该是gremlins.html #结语解谜这就告一段落啦！从这段解谜的过程中学到了很多有关图像处理、网络请求、文件结构方面的东西。真的推荐正在学习python甚至是精通python的朋友们试一下。 还有一件事，32关我会写一下的，过一阵的。^.^","link":"/2022/zh-cn/pythonchallenge2"},{"title":"Xpath学习笔记","text":"It&apos;s been a while. #前言最近在做一些数据抓取的事情。利用xpath在网页中定位元素十分便捷，而且理解了就容易上手 简单来说，把整个html网页视作为一棵大树，那么xpath则通过告诉你如何在每个树杈处拐弯从而到达目的终端枝桠 html网页结构应该都有数吧 要使用xpath进行元素查找，需要先引入lxml模块 123import requestsfrom lxml import etreehtml_page = etree.HTML(requests.get(url).text) 接下来，定位对应的元素就很简单了，html_page.xpath(f&quot;{xpath_expression}&quot;)。 #其他定位元素很简单，但xpath表达式相对而言就稍微复杂点了 W3schools上面有很详细的xpath教程，基本上这个教程看懂也就能够上手xpath了 我这里想写一点我这段时间总结的几个事情 至少目前为止，还不能同事通过名称和次序来定位元素。例如如下html段落中，要定位go，那么xpath表达式应该是&apos;//div[@class=&quot;main&quot;]/div[5]/p/text()&apos;，意为主div下的第五个div，而无法通过表达主div下第三个类名称为&quot;h&quot;的div来定位 1234567&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;h&quot;&gt;&lt;p&gt;He&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;j&quot;&gt;&lt;p&gt;and&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;J&quot;&gt;&lt;p&gt;I&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;h&quot;&gt;&lt;p&gt;will&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;h&quot;&gt;&lt;p&gt;go&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 可能这个例子看起来并没有那么复杂，但如果主div下有上千个div呢？实际的html网页中基本不可能找到上面这样简单的段落。所以如果你想同事利用名称和次序来定位一个元素的话，想想别的办法吧^.^ 几乎每个浏览器都可以通过检查元素的方法直接复制xpath。例如Microsoft Edge中按快捷键F12即可进入开发者工具箱。在对应的源码位值右键点击即可找到复制-&gt;复制xpath选项。不够，当你使用requests去get一个页面的时候，获得的页面代码和开发者工具中显示的源码有那么一点点区别。网上可以找到很多有关这两处代码区别的信息。 或许可以试试POST方法，过一段时间试试看 永远不会有一篇能够教会你所有东西的教程。当你面对实际问题是总是要尝试些不同的东西。有时候元素在页面上显示的很呈规律，但在实际定位中可能需要一个元素一个元素地进行定位，这时候耐心就很重要了。 遇到问题继续补充在这里","link":"/2022/zh-cn/xpathNotes"}],"tags":[{"name":"python","slug":"python","link":"/zh-cn/tags/python/"},{"name":"Travel","slug":"Travel","link":"/zh-cn/tags/Travel/"},{"name":"Pixel Experience","slug":"Pixel-Experience","link":"/zh-cn/tags/Pixel-Experience/"},{"name":"shell","slug":"shell","link":"/zh-cn/tags/shell/"},{"name":"front end","slug":"front-end","link":"/zh-cn/tags/front-end/"}],"categories":[{"name":"Thoughts","slug":"Thoughts","link":"/zh-cn/categories/Thoughts/"},{"name":"code","slug":"code","link":"/zh-cn/categories/code/"},{"name":"Android","slug":"Android","link":"/zh-cn/categories/Android/"},{"name":"router","slug":"router","link":"/zh-cn/categories/router/"}]}